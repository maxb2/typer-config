{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"typer-config","text":"<p>This is a collection of utilities to use configuration files to set parameters for a typer CLI. It is useful for typer commands with many options/arguments so you don't have to constantly rewrite long commands. This package was inspired by phha/click_config_file and prototyped in this issue. It allows you to set values for CLI parameters using a configuration file. </p> <pre><code># Long commands like this:\n$ my-typer-app --greeting Hello --suffix \"!\" World\n\n# Can become this:\n$ my-typer-app --config config.yml\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>You can use a decorator to quickly add a configuration parameter to your <code>typer</code> application:</p> <pre><code>import typer\nfrom typer_config import use_yaml_config  # other formats available (1)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_yaml_config()  # MUST BE AFTER @app.command() (2)\ndef main(name: str, greeting: str = \"Hello\"): ...\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <ol> <li> <p>This package also provides <code>use_json_config</code>, <code>use_toml_config</code>, <code>use_ini_config</code>, and <code>use_dotenv_config</code> for those file formats.    You can also use your own loader function and the <code>@use_config(loader_func)</code> decorator.</p> <p>Note that since INI requires a top-level section <code>use_ini_config</code> requires a list of strings that express the path to the section    you wish to use, e.g. <code>@use_ini_config([\"section\", \"subsection\", ...])</code>. </p> </li> <li> <p>The <code>app.command()</code> decorator registers the function object in a lookup table, so we must transform our command before registration.</p> </li> </ol> <p>Your typer command will now include a <code>--config CONFIG_FILE</code> option at the command line.</p> <p>See Examples for more use cases.</p>"},{"location":"api/","title":"typer_config","text":"<p>Typer Configuration Utilities.</p>"},{"location":"api/#typer_config.dotenv_conf_callback","title":"dotenv_conf_callback  <code>module-attribute</code>","text":"<pre><code>dotenv_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(\n        loader_transformer(\n            dotenv_loader,\n            loader_conditional=lambda param_value: param_value,\n        )\n    )\n)\n</code></pre> <p>Dotenv typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.json_conf_callback","title":"json_conf_callback  <code>module-attribute</code>","text":"<pre><code>json_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(\n        loader_transformer(\n            json_loader,\n            loader_conditional=lambda param_value: param_value,\n        )\n    )\n)\n</code></pre> <p>JSON typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.toml_conf_callback","title":"toml_conf_callback  <code>module-attribute</code>","text":"<pre><code>toml_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(\n        loader_transformer(\n            toml_loader,\n            loader_conditional=lambda param_value: param_value,\n        )\n    )\n)\n</code></pre> <p>TOML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.yaml_conf_callback","title":"yaml_conf_callback  <code>module-attribute</code>","text":"<pre><code>yaml_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(\n        loader_transformer(\n            yaml_loader,\n            loader_conditional=lambda param_value: param_value,\n        )\n    )\n)\n</code></pre> <p>YAML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.conf_callback_factory","title":"conf_callback_factory","text":"<pre><code>conf_callback_factory(\n    loader: ConfigLoader,\n) -&gt; ConfigParameterCallback\n</code></pre> <p>Typer configuration callback factory.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Config loader function that takes the value passed to the typer CLI and returns a dictionary that is applied to the click context's default map.</p> required <p>Returns:</p> Name Type Description <code>ConfigParameterCallback</code> <code>ConfigParameterCallback</code> <p>Configuration parameter callback function.</p> Source code in <code>src/typer_config/callbacks.py</code> <pre><code>def conf_callback_factory(loader: ConfigLoader) -&gt; ConfigParameterCallback:\n    \"\"\"Typer configuration callback factory.\n\n    Args:\n        loader (ConfigLoader): Config loader function that takes the value\n            passed to the typer CLI and returns a dictionary that is\n            applied to the click context's default map.\n\n    Returns:\n        ConfigParameterCallback: Configuration parameter callback function.\n    \"\"\"\n\n    def _callback(\n        ctx: Context, param: CallbackParam, param_value: TyperParameterValue\n    ) -&gt; TyperParameterValue:\n        \"\"\"Generated typer config parameter callback.\n\n        Args:\n            ctx (typer.Context): typer context (automatically passed)\n            param (typer.CallbackParam): typer callback parameter (automatically passed)\n            param_value (TyperParameterValue): parameter value passed to typer\n                (automatically passed)\n\n        Raises:\n            BadParameter: bad parameter value\n\n        Returns:\n            TyperParameterValue: must return back the given parameter\n        \"\"\"\n        try:\n            conf = loader(param_value)  # Load config file\n            ctx.default_map = ctx.default_map or {}  # Initialize the default map\n            ctx.default_map.update(conf)  # Merge the config Dict into default_map\n        except Exception as ex:\n            raise BadParameter(str(ex), ctx=ctx, param=param) from ex\n        return param_value\n\n    return _callback\n</code></pre>"},{"location":"api/#typer_config.use_config","title":"use_config","text":"<pre><code>use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_config\nfrom typer_config import yaml_conf_callback # whichever callback to use\n\napp = typer.Typer()\n\n@app.command()\n@use_config(yaml_conf_callback)\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>ConfigParameterCallback</code> <p>config parameter callback to load</p> required <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_config\n        from typer_config import yaml_conf_callback # whichever callback to use\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_config(yaml_conf_callback)\n        def main(...):\n            ...\n        ```\n\n    Args:\n        callback (ConfigParameterCallback): config parameter callback to load\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    def decorator(cmd: TyperCommand) -&gt; TyperCommand:\n        # NOTE: modifying a function's __signature__ is dangerous\n        # in the sense that it only affects inspect.signature().\n        # It does not affect the actual function implementation.\n        # So, a caller can be confused how to pass parameters to\n        # the function with modified signature.\n        sig = signature(cmd, eval_str=True)\n\n        config_param = Parameter(\n            param_name,\n            kind=Parameter.KEYWORD_ONLY,\n            annotation=str,\n            default=Option(\"\", callback=callback, is_eager=True, help=param_help),\n        )\n\n        new_sig = sig.replace(parameters=[*sig.parameters.values(), config_param])\n\n        @wraps(cmd)\n        def wrapped(*args, **kwargs):  # noqa: ANN202,ANN002,ANN003\n            # NOTE: need to delete the config parameter\n            # to match the wrapped command's signature.\n            kwargs.pop(param_name, None)\n\n            return cmd(*args, **kwargs)\n\n        wrapped.__signature__ = new_sig  # type: ignore\n\n        return wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/#typer_config.use_fallback_config","title":"use_fallback_config","text":"<pre><code>use_fallback_config(\n    fallback_files: List[TyperParameterValue],\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using a fallback list of configuration files.</p> <p>Only the first existing configuration file is used. Files are checked in order from first to last.</p> <p>This is useful for fallback configurations, e.g.: - Use local config if it exists: <code>./myapp.yaml</code> - Otherwise, use user config: <code>~/.config/myapp.yaml</code> - Otherwise, use system config: <code>/etc/myapp.yaml</code></p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_fallback_config\n\napp = typer.Typer()\n\n@app.command()\n@use_fallback_config([\n    \"./myapp.yaml\",           # highest priority\n    \"~/.config/myapp.yaml\",\n    \"/etc/myapp.yaml\",        # lowest priority\n])\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fallback_files</code> <code>List[TyperParameterValue]</code> <p>List of file paths to try, in order of priority (first has highest priority). The first existing file will be used.</p> required <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_fallback_config(\n    fallback_files: List[TyperParameterValue],\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using a fallback list of configuration files.\n\n    Only the first existing configuration file is used. Files are checked\n    in order from first to last.\n\n    This is useful for fallback configurations, e.g.:\n    - Use local config if it exists: `./myapp.yaml`\n    - Otherwise, use user config: `~/.config/myapp.yaml`\n    - Otherwise, use system config: `/etc/myapp.yaml`\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_fallback_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_fallback_config([\n            \"./myapp.yaml\",           # highest priority\n            \"~/.config/myapp.yaml\",\n            \"/etc/myapp.yaml\",        # lowest priority\n        ])\n        def main(...):\n            ...\n        ```\n\n    Args:\n        fallback_files (List[TyperParameterValue]): List of file paths to try,\n            in order of priority (first has highest priority).\n            The first existing file will be used.\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            multifile_fallback_loader,\n            loader_conditional=lambda _: True,  # always load\n            param_transformer=lambda param_value: (\n                [param_value, *fallback_files] if param_value else fallback_files\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.use_ini_config","title":"use_ini_config","text":"<pre><code>use_ini_config(\n    section: List[str],\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using INI configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_ini_config\n\napp = typer.Typer()\n\n@app.command()\n@use_ini_config([\"section\", \"subsection\"])\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the INI file.</p> required <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_ini_config(\n    section: List[str],\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using INI configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_ini_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_ini_config([\"section\", \"subsection\"])\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str]): List of nested sections to access in the INI file.\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            ini_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.use_json_config","title":"use_json_config","text":"<pre><code>use_json_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using JSON configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_json_config\n\napp = typer.Typer()\n\n@app.command()\n@use_json_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_json_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using JSON configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_json_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_json_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            json_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.use_multifile_config","title":"use_multifile_config","text":"<pre><code>use_multifile_config(\n    default_files: List[TyperParameterValue],\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using multiple configuration files on a typer command.</p> <p>Multiple config files are merged together, with later files overriding earlier ones. Files that don't exist are skipped. Nested dictionaries are deep-merged.</p> <p>This is useful for configuration inheritance, e.g.: - Start with system defaults: <code>/etc/myapp.yaml</code> - Override with user config: <code>~/.config/myapp.yaml</code> - Override with local config: <code>./myapp.yaml</code> - Override with --config option if provided</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_multifile_config\n\napp = typer.Typer()\n\n@app.command()\n@use_multifile_config([\n    \"/etc/myapp.yaml\",\n    \"~/.config/myapp.yaml\",\n    \"./myapp.yaml\",\n])\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default_files</code> <code>List[TyperParameterValue]</code> <p>List of default file paths to load. Files are processed in order, with later files overriding earlier ones. Missing files are silently skipped.</p> required <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_multifile_config(\n    default_files: List[TyperParameterValue],\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using multiple configuration files on a typer command.\n\n    Multiple config files are merged together, with later files overriding\n    earlier ones. Files that don't exist are skipped. Nested dictionaries\n    are deep-merged.\n\n    This is useful for configuration inheritance, e.g.:\n    - Start with system defaults: `/etc/myapp.yaml`\n    - Override with user config: `~/.config/myapp.yaml`\n    - Override with local config: `./myapp.yaml`\n    - Override with --config option if provided\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_multifile_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_multifile_config([\n            \"/etc/myapp.yaml\",\n            \"~/.config/myapp.yaml\",\n            \"./myapp.yaml\",\n        ])\n        def main(...):\n            ...\n        ```\n\n    Args:\n        default_files (List[TyperParameterValue]): List of default file paths to load.\n            Files are processed in order, with later files overriding earlier ones.\n            Missing files are silently skipped.\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            multifile_loader,\n            loader_conditional=lambda _: True,  # always load\n            param_transformer=lambda param_value: (\n                [*default_files, param_value] if param_value else default_files\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.use_toml_config","title":"use_toml_config","text":"<pre><code>use_toml_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using TOML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_toml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_toml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_toml_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using TOML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_toml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_toml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            toml_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.use_yaml_config","title":"use_yaml_config","text":"<pre><code>use_yaml_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using YAML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_yaml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_yaml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_yaml_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using YAML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_yaml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_yaml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            yaml_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.dotenv_loader","title":"dotenv_loader","text":"<pre><code>dotenv_loader(\n    param_value: TyperParameterValue,\n) -&gt; ConfigDict\n</code></pre> <p>Dotenv file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of Dotenv file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>python-dotenv library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def dotenv_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"Dotenv file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of Dotenv file\n\n    Raises:\n        ModuleNotFoundError: python-dotenv library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    dotenv = try_import(\"dotenv\")\n\n    if dotenv is None:  # pragma: no cover\n        message = \"Please install the python-dotenv library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        # NOTE: I'm using a stream here so that the loader\n        # will raise an exception when the file doesn't exist.\n        conf: ConfigDict = dotenv.dotenv_values(stream=_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.ini_loader","title":"ini_loader","text":"<pre><code>ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>INI file loader.</p> Note <p>INI files must have sections at the top level. You probably want to combine this with <code>loader_transformer</code> to extract the correct section. For example: <pre><code>ini_section_loader = loader_transformer(\n    ini_loader,\n    config_transformer=lambda config: config[\"section\"],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of INI file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"INI file loader.\n\n    Note:\n        INI files must have sections at the top level.\n        You probably want to combine this with `loader_transformer`\n        to extract the correct section.\n        For example:\n        ```py\n        ini_section_loader = loader_transformer(\n            ini_loader,\n            config_transformer=lambda config: config[\"section\"],\n        )\n        ```\n\n    Args:\n        param_value (TyperParameterValue): path of INI file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    ini_parser = ConfigParser()\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        ini_parser.read_file(_file)\n\n    conf: ConfigDict = {\n        sect: dict(ini_parser.items(sect)) for sect in ini_parser.sections()\n    }\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.json_loader","title":"json_loader","text":"<pre><code>json_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>JSON file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of JSON file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def json_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"JSON file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of JSON file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = json.load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.multifile_fallback_loader","title":"multifile_fallback_loader","text":"<pre><code>multifile_fallback_loader(\n    files: list[TyperParameterValue],\n) -&gt; ConfigDict\n</code></pre> <p>Loader that uses the first existing configuration file from a list.</p> <p>Files are checked in order. The first file that exists is loaded and returned. This is useful for fallback configurations (e.g., local -&gt; user -&gt; system).</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[TyperParameterValue]</code> <p>List of paths to configuration files, in order of priority (first has highest priority).</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>Dictionary loaded from the first existing file, or empty dict if no files exist.</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def multifile_fallback_loader(files: list[TyperParameterValue]) -&gt; ConfigDict:\n    \"\"\"Loader that uses the first existing configuration file from a list.\n\n    Files are checked in order. The first file that exists is loaded and returned.\n    This is useful for fallback configurations (e.g., local -&gt; user -&gt; system).\n\n    Args:\n        files (list[TyperParameterValue]): List of paths to configuration files,\n            in order of priority (first has highest priority).\n\n    Returns:\n        ConfigDict: Dictionary loaded from the first existing file,\n            or empty dict if no files exist.\n    \"\"\"\n    for file_path in files:\n\n        if Path(file_path).is_file():\n            loader = _get_loader_for_file(file_path)\n            return loader(file_path)\n\n    return {}\n</code></pre>"},{"location":"api/#typer_config.multifile_loader","title":"multifile_loader","text":"<pre><code>multifile_loader(\n    files: list[TyperParameterValue],\n    *,\n    skip_missing: bool = True,\n    deep_merge: bool = True\n) -&gt; ConfigDict\n</code></pre> <p>Loader that merges multiple configuration files into one dictionary.</p> <p>Files are processed in order, with later files overriding earlier ones. Missing files are skipped by default.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[TyperParameterValue]</code> <p>List of paths to configuration files.</p> required <code>skip_missing</code> <code>bool</code> <p>Skip files that don't exist. Defaults to True.</p> <code>True</code> <code>deep_merge</code> <code>bool</code> <p>Deep merge nested dictionaries. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>Merged dictionary loaded from all files.</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def multifile_loader(\n    files: list[TyperParameterValue],\n    *,\n    skip_missing: bool = True,\n    deep_merge: bool = True,\n) -&gt; ConfigDict:\n    \"\"\"Loader that merges multiple configuration files into one dictionary.\n\n    Files are processed in order, with later files overriding earlier ones.\n    Missing files are skipped by default.\n\n    Args:\n        files (list[TyperParameterValue]): List of paths to configuration files.\n        skip_missing (bool, optional): Skip files that don't exist.\n            Defaults to True.\n        deep_merge (bool, optional): Deep merge nested dictionaries.\n            Defaults to True.\n\n    Returns:\n        ConfigDict: Merged dictionary loaded from all files.\n    \"\"\"\n    merged_config: ConfigDict = {}\n\n    for file_path in files:\n        if not file_path:\n            continue\n\n        if skip_missing and not Path(file_path).is_file():\n            continue\n\n        loader = _get_loader_for_file(file_path)\n        config = loader(file_path)\n\n        if deep_merge:\n            merged_config = _deep_merge(merged_config, config)\n        else:\n            merged_config.update(config)\n\n    return merged_config\n</code></pre>"},{"location":"api/#typer_config.toml_loader","title":"toml_loader","text":"<pre><code>toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>TOML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of TOML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>toml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"TOML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of TOML file\n\n    Raises:\n        ModuleNotFoundError: toml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    # try `tomllib` first\n    tomllib = try_import(\"tomllib\")\n\n    if tomllib is not None:\n        with open(param_value, \"rb\") as _file:\n            return tomllib.load(_file)\n\n    # couldn't find `tommllib`, so try `toml`\n    toml = try_import(\"toml\")\n\n    if toml is None:  # pragma: no cover\n        message = \"Please install the toml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        return toml.load(_file)\n</code></pre>"},{"location":"api/#typer_config.yaml_loader","title":"yaml_loader","text":"<pre><code>yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>YAML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of YAML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>pyyaml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"YAML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of YAML file\n\n    Raises:\n        ModuleNotFoundError: pyyaml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    yaml = try_import(\"yaml\")\n\n    if yaml is None:  # pragma: no cover\n        message = \"Please install the pyyaml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = yaml.safe_load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.__optional_imports","title":"__optional_imports","text":"<p>Handle optional imports.</p>"},{"location":"api/#typer_config.__optional_imports.try_import","title":"try_import  <code>cached</code>","text":"<pre><code>try_import(module_name: str)\n</code></pre> <p>Try to import a module by name.</p> <p>Note: caches the imported modules in a <code>functools.lru_cache</code></p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>name of module to import</p> required <p>Returns:</p> Name Type Description <code>Module</code> <p>imported module</p> Source code in <code>src/typer_config/__optional_imports.py</code> <pre><code>@lru_cache()\ndef try_import(module_name: str):  # noqa: ANN202 (no type for modules)\n    \"\"\"Try to import a module by name.\n\n    Note: caches the imported modules in a `functools.lru_cache`\n\n    Args:\n        module_name (str): name of module to import\n\n    Returns:\n        Module: imported module\n    \"\"\"\n    if find_spec(module_name):\n        return import_module(module_name)\n    return None\n</code></pre>"},{"location":"api/#typer_config.__typing","title":"__typing","text":"<p>Data and Function types.</p>"},{"location":"api/#typer_config.__typing.TyperParameterName","title":"TyperParameterName  <code>module-attribute</code>","text":"<pre><code>TyperParameterName: TypeAlias = str\n</code></pre> <p>Typer CLI parameter name.</p>"},{"location":"api/#typer_config.__typing.TyperParameterValue","title":"TyperParameterValue  <code>module-attribute</code>","text":"<pre><code>TyperParameterValue: TypeAlias = Any\n</code></pre> <p>Typer CLI parameter value.</p>"},{"location":"api/#typer_config.__typing.ConfigDict","title":"ConfigDict  <code>module-attribute</code>","text":"<pre><code>ConfigDict: TypeAlias = Dict[TyperParameterName, Any]\n</code></pre> <p>Configuration dictionary to be applied to the click context default map.</p>"},{"location":"api/#typer_config.__typing.FilePath","title":"FilePath  <code>module-attribute</code>","text":"<pre><code>FilePath: TypeAlias = Union[Path, str]\n</code></pre> <p>File path</p>"},{"location":"api/#typer_config.__typing.TyperParameterValueTransformer","title":"TyperParameterValueTransformer  <code>module-attribute</code>","text":"<pre><code>TyperParameterValueTransformer: TypeAlias = Callable[\n    [TyperParameterValue], TyperParameterValue\n]\n</code></pre> <p>Typer parameter value transforming function.</p>"},{"location":"api/#typer_config.__typing.ConfigDictTransformer","title":"ConfigDictTransformer  <code>module-attribute</code>","text":"<pre><code>ConfigDictTransformer: TypeAlias = Callable[\n    [ConfigDict], ConfigDict\n]\n</code></pre> <p>ConfigDict transforming function.</p>"},{"location":"api/#typer_config.__typing.ConfigLoader","title":"ConfigLoader  <code>module-attribute</code>","text":"<pre><code>ConfigLoader: TypeAlias = Callable[\n    [TyperParameterValue], ConfigDict\n]\n</code></pre> <p>Configuration loader function.</p>"},{"location":"api/#typer_config.__typing.ConfigLoaderConditional","title":"ConfigLoaderConditional  <code>module-attribute</code>","text":"<pre><code>ConfigLoaderConditional: TypeAlias = Callable[\n    [TyperParameterValue], bool\n]\n</code></pre> <p>Configuration loader conditional function.</p>"},{"location":"api/#typer_config.__typing.ConfigParameterCallback","title":"ConfigParameterCallback  <code>module-attribute</code>","text":"<pre><code>ConfigParameterCallback: TypeAlias = Callable[\n    [Context, CallbackParam, TyperParameterValue],\n    TyperParameterValue,\n]\n</code></pre> <p>Typer config parameter callback function.</p>"},{"location":"api/#typer_config.__typing.ConfigDumper","title":"ConfigDumper  <code>module-attribute</code>","text":"<pre><code>ConfigDumper: TypeAlias = Callable[\n    [ConfigDict, FilePath], None\n]\n</code></pre> <p>Configuration dumper function.</p>"},{"location":"api/#typer_config.__typing.TyperCommand","title":"TyperCommand  <code>module-attribute</code>","text":"<pre><code>TyperCommand: TypeAlias = Callable[..., Any]\n</code></pre> <p>A function that will be decorated with <code>typer.Typer().command()</code>.</p>"},{"location":"api/#typer_config.__typing.TyperCommandDecorator","title":"TyperCommandDecorator  <code>module-attribute</code>","text":"<pre><code>TyperCommandDecorator: TypeAlias = Callable[\n    [TyperCommand], TyperCommand\n]\n</code></pre> <p>A decorator applied to a typer command.</p>"},{"location":"api/#typer_config.callbacks","title":"callbacks","text":"<p>Typer Configuration Parameter Callbacks.</p>"},{"location":"api/#typer_config.callbacks.yaml_conf_callback","title":"yaml_conf_callback  <code>module-attribute</code>","text":"<pre><code>yaml_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(\n        loader_transformer(\n            yaml_loader,\n            loader_conditional=lambda param_value: param_value,\n        )\n    )\n)\n</code></pre> <p>YAML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.json_conf_callback","title":"json_conf_callback  <code>module-attribute</code>","text":"<pre><code>json_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(\n        loader_transformer(\n            json_loader,\n            loader_conditional=lambda param_value: param_value,\n        )\n    )\n)\n</code></pre> <p>JSON typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.toml_conf_callback","title":"toml_conf_callback  <code>module-attribute</code>","text":"<pre><code>toml_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(\n        loader_transformer(\n            toml_loader,\n            loader_conditional=lambda param_value: param_value,\n        )\n    )\n)\n</code></pre> <p>TOML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.dotenv_conf_callback","title":"dotenv_conf_callback  <code>module-attribute</code>","text":"<pre><code>dotenv_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(\n        loader_transformer(\n            dotenv_loader,\n            loader_conditional=lambda param_value: param_value,\n        )\n    )\n)\n</code></pre> <p>Dotenv typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.conf_callback_factory","title":"conf_callback_factory","text":"<pre><code>conf_callback_factory(\n    loader: ConfigLoader,\n) -&gt; ConfigParameterCallback\n</code></pre> <p>Typer configuration callback factory.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Config loader function that takes the value passed to the typer CLI and returns a dictionary that is applied to the click context's default map.</p> required <p>Returns:</p> Name Type Description <code>ConfigParameterCallback</code> <code>ConfigParameterCallback</code> <p>Configuration parameter callback function.</p> Source code in <code>src/typer_config/callbacks.py</code> <pre><code>def conf_callback_factory(loader: ConfigLoader) -&gt; ConfigParameterCallback:\n    \"\"\"Typer configuration callback factory.\n\n    Args:\n        loader (ConfigLoader): Config loader function that takes the value\n            passed to the typer CLI and returns a dictionary that is\n            applied to the click context's default map.\n\n    Returns:\n        ConfigParameterCallback: Configuration parameter callback function.\n    \"\"\"\n\n    def _callback(\n        ctx: Context, param: CallbackParam, param_value: TyperParameterValue\n    ) -&gt; TyperParameterValue:\n        \"\"\"Generated typer config parameter callback.\n\n        Args:\n            ctx (typer.Context): typer context (automatically passed)\n            param (typer.CallbackParam): typer callback parameter (automatically passed)\n            param_value (TyperParameterValue): parameter value passed to typer\n                (automatically passed)\n\n        Raises:\n            BadParameter: bad parameter value\n\n        Returns:\n            TyperParameterValue: must return back the given parameter\n        \"\"\"\n        try:\n            conf = loader(param_value)  # Load config file\n            ctx.default_map = ctx.default_map or {}  # Initialize the default map\n            ctx.default_map.update(conf)  # Merge the config Dict into default_map\n        except Exception as ex:\n            raise BadParameter(str(ex), ctx=ctx, param=param) from ex\n        return param_value\n\n    return _callback\n</code></pre>"},{"location":"api/#typer_config.callbacks.argument_list_callback","title":"argument_list_callback","text":"<pre><code>argument_list_callback(\n    ctx: Context,\n    param: CallbackParam,\n    param_value: Optional[List[str]],\n) -&gt; List[str]\n</code></pre> <p>Argument list callback.</p> Note <p>This is a shim to fix list arguments in a config. See maxb2/typer-config#124.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>typer context</p> required <code>param</code> <code>CallbackParam</code> <p>typer parameter</p> required <code>param_value</code> <code>Optional[List[str]]</code> <p>typer parameter value</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: argument list</p> Source code in <code>src/typer_config/callbacks.py</code> <pre><code>def argument_list_callback(\n    ctx: Context, param: CallbackParam, param_value: Optional[List[str]]\n) -&gt; List[str]:\n    \"\"\"Argument list callback.\n\n    Note:\n        This is a shim to fix list arguments in a config.\n        See [maxb2/typer-config#124](https://github.com/maxb2/typer-config/issues/124).\n\n    Args:\n        ctx (typer.Context): typer context\n        param (typer.CallbackParam): typer parameter\n        param_value (Optional[List[str]]): typer parameter value\n\n    Returns:\n        List[str]: argument list\n    \"\"\"\n    ctx.default_map = ctx.default_map or {}\n    default = ctx.default_map.get(param.name, []) if param.name else []\n    return param_value if param_value else default\n</code></pre>"},{"location":"api/#typer_config.decorators","title":"decorators","text":"<p>Typer Config decorators.</p>"},{"location":"api/#typer_config.decorators.use_config","title":"use_config","text":"<pre><code>use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_config\nfrom typer_config import yaml_conf_callback # whichever callback to use\n\napp = typer.Typer()\n\n@app.command()\n@use_config(yaml_conf_callback)\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>ConfigParameterCallback</code> <p>config parameter callback to load</p> required <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_config\n        from typer_config import yaml_conf_callback # whichever callback to use\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_config(yaml_conf_callback)\n        def main(...):\n            ...\n        ```\n\n    Args:\n        callback (ConfigParameterCallback): config parameter callback to load\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    def decorator(cmd: TyperCommand) -&gt; TyperCommand:\n        # NOTE: modifying a function's __signature__ is dangerous\n        # in the sense that it only affects inspect.signature().\n        # It does not affect the actual function implementation.\n        # So, a caller can be confused how to pass parameters to\n        # the function with modified signature.\n        sig = signature(cmd, eval_str=True)\n\n        config_param = Parameter(\n            param_name,\n            kind=Parameter.KEYWORD_ONLY,\n            annotation=str,\n            default=Option(\"\", callback=callback, is_eager=True, help=param_help),\n        )\n\n        new_sig = sig.replace(parameters=[*sig.parameters.values(), config_param])\n\n        @wraps(cmd)\n        def wrapped(*args, **kwargs):  # noqa: ANN202,ANN002,ANN003\n            # NOTE: need to delete the config parameter\n            # to match the wrapped command's signature.\n            kwargs.pop(param_name, None)\n\n            return cmd(*args, **kwargs)\n\n        wrapped.__signature__ = new_sig  # type: ignore\n\n        return wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/#typer_config.decorators.use_json_config","title":"use_json_config","text":"<pre><code>use_json_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using JSON configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_json_config\n\napp = typer.Typer()\n\n@app.command()\n@use_json_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_json_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using JSON configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_json_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_json_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            json_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.decorators.use_yaml_config","title":"use_yaml_config","text":"<pre><code>use_yaml_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using YAML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_yaml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_yaml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_yaml_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using YAML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_yaml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_yaml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            yaml_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.decorators.use_toml_config","title":"use_toml_config","text":"<pre><code>use_toml_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using TOML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_toml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_toml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_toml_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using TOML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_toml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_toml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            toml_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.decorators.use_dotenv_config","title":"use_dotenv_config","text":"<pre><code>use_dotenv_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using dotenv configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_dotenv_config\n\napp = typer.Typer()\n\n@app.command()\n@use_dotenv_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_dotenv_config(\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using dotenv configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_dotenv_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_dotenv_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            dotenv_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.decorators.use_ini_config","title":"use_ini_config","text":"<pre><code>use_ini_config(\n    section: List[str],\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using INI configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_ini_config\n\napp = typer.Typer()\n\n@app.command()\n@use_ini_config([\"section\", \"subsection\"])\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the INI file.</p> required <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <code>default_value</code> <code>TyperParameterValue</code> <p>default config parameter value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_ini_config(\n    section: List[str],\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n    default_value: Optional[TyperParameterValue] = None,\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using INI configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_ini_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_ini_config([\"section\", \"subsection\"])\n        def main(...):\n            ...\n        ```\n\n    Args:\n        section (List[str]): List of nested sections to access in the INI file.\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n        default_value (TyperParameterValue, optional): default config parameter value.\n            Defaults to None.\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            ini_loader,\n            loader_conditional=lambda param_value: (\n                file_exists_and_warn(param_value) if param_value else param_value\n            ),\n            param_transformer=(\n                (lambda param_value: param_value if param_value else default_value)\n                if default_value is not None\n                else None\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.decorators.use_multifile_config","title":"use_multifile_config","text":"<pre><code>use_multifile_config(\n    default_files: List[TyperParameterValue],\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using multiple configuration files on a typer command.</p> <p>Multiple config files are merged together, with later files overriding earlier ones. Files that don't exist are skipped. Nested dictionaries are deep-merged.</p> <p>This is useful for configuration inheritance, e.g.: - Start with system defaults: <code>/etc/myapp.yaml</code> - Override with user config: <code>~/.config/myapp.yaml</code> - Override with local config: <code>./myapp.yaml</code> - Override with --config option if provided</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_multifile_config\n\napp = typer.Typer()\n\n@app.command()\n@use_multifile_config([\n    \"/etc/myapp.yaml\",\n    \"~/.config/myapp.yaml\",\n    \"./myapp.yaml\",\n])\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default_files</code> <code>List[TyperParameterValue]</code> <p>List of default file paths to load. Files are processed in order, with later files overriding earlier ones. Missing files are silently skipped.</p> required <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_multifile_config(\n    default_files: List[TyperParameterValue],\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using multiple configuration files on a typer command.\n\n    Multiple config files are merged together, with later files overriding\n    earlier ones. Files that don't exist are skipped. Nested dictionaries\n    are deep-merged.\n\n    This is useful for configuration inheritance, e.g.:\n    - Start with system defaults: `/etc/myapp.yaml`\n    - Override with user config: `~/.config/myapp.yaml`\n    - Override with local config: `./myapp.yaml`\n    - Override with --config option if provided\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_multifile_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_multifile_config([\n            \"/etc/myapp.yaml\",\n            \"~/.config/myapp.yaml\",\n            \"./myapp.yaml\",\n        ])\n        def main(...):\n            ...\n        ```\n\n    Args:\n        default_files (List[TyperParameterValue]): List of default file paths to load.\n            Files are processed in order, with later files overriding earlier ones.\n            Missing files are silently skipped.\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            multifile_loader,\n            loader_conditional=lambda _: True,  # always load\n            param_transformer=lambda param_value: (\n                [*default_files, param_value] if param_value else default_files\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.decorators.use_fallback_config","title":"use_fallback_config","text":"<pre><code>use_fallback_config(\n    fallback_files: List[TyperParameterValue],\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using a fallback list of configuration files.</p> <p>Only the first existing configuration file is used. Files are checked in order from first to last.</p> <p>This is useful for fallback configurations, e.g.: - Use local config if it exists: <code>./myapp.yaml</code> - Otherwise, use user config: <code>~/.config/myapp.yaml</code> - Otherwise, use system config: <code>/etc/myapp.yaml</code></p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_fallback_config\n\napp = typer.Typer()\n\n@app.command()\n@use_fallback_config([\n    \"./myapp.yaml\",           # highest priority\n    \"~/.config/myapp.yaml\",\n    \"/etc/myapp.yaml\",        # lowest priority\n])\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fallback_files</code> <code>List[TyperParameterValue]</code> <p>List of file paths to try, in order of priority (first has highest priority). The first existing file will be used.</p> required <code>section</code> <code>List[str]</code> <p>List of nested sections to access in the config. Defaults to None.</p> <code>None</code> <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def use_fallback_config(\n    fallback_files: List[TyperParameterValue],\n    section: Optional[List[str]] = None,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for using a fallback list of configuration files.\n\n    Only the first existing configuration file is used. Files are checked\n    in order from first to last.\n\n    This is useful for fallback configurations, e.g.:\n    - Use local config if it exists: `./myapp.yaml`\n    - Otherwise, use user config: `~/.config/myapp.yaml`\n    - Otherwise, use system config: `/etc/myapp.yaml`\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_fallback_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_fallback_config([\n            \"./myapp.yaml\",           # highest priority\n            \"~/.config/myapp.yaml\",\n            \"/etc/myapp.yaml\",        # lowest priority\n        ])\n        def main(...):\n            ...\n        ```\n\n    Args:\n        fallback_files (List[TyperParameterValue]): List of file paths to try,\n            in order of priority (first has highest priority).\n            The first existing file will be used.\n        section (List[str], optional): List of nested sections to access in the config.\n            Defaults to None.\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    callback = conf_callback_factory(\n        loader_transformer(\n            multifile_fallback_loader,\n            loader_conditional=lambda _: True,  # always load\n            param_transformer=lambda param_value: (\n                [param_value, *fallback_files] if param_value else fallback_files\n            ),\n            config_transformer=lambda config: get_dict_section(config, section),\n        )\n    )\n\n    return use_config(callback=callback, param_name=param_name, param_help=param_help)\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_config","title":"dump_config","text":"<pre><code>dump_config(\n    dumper: ConfigDumper, location: FilePath\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a config file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_config MUST BE AFTER @app.command()\n@dump_config(yaml_dumper, \"config_dump_dir/params.yaml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>ConfigDumper</code> <p>config file dumper</p> required <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def dump_config(dumper: ConfigDumper, location: FilePath) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for dumping a config file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_config MUST BE AFTER @app.command()\n        @dump_config(yaml_dumper, \"config_dump_dir/params.yaml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        dumper (ConfigDumper): config file dumper\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n\n    def decorator(cmd: TyperCommand) -&gt; TyperCommand:\n        @wraps(cmd)\n        def inner(*args, **kwargs):  # noqa: ANN202,ANN002,ANN003\n            # get a dictionary of the passed args\n            bound_args = signature(cmd).bind(*args, **kwargs).arguments\n\n            # convert enums to their values\n            # NOTE: bound_args shouldn't be nested in the typer\n            # framework, so top level iteration should be fine.\n            for key, val in bound_args.items():\n                if isinstance(val, Enum):\n                    bound_args[key] = val.value\n\n            # dump passed args\n            dumper(bound_args, location)\n\n            # run original command\n            return cmd(*args, **kwargs)\n\n        return inner\n\n    return decorator\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_json_config","title":"dump_json_config","text":"<pre><code>dump_json_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a JSON file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_json_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_json_config MUST BE AFTER @app.command()\n@dump_json_config(\"config_dump_dir/params.json\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def dump_json_config(location: FilePath) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for dumping a JSON file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_json_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_json_config MUST BE AFTER @app.command()\n        @dump_json_config(\"config_dump_dir/params.json\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=json_dumper, location=location)\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_yaml_config","title":"dump_yaml_config","text":"<pre><code>dump_yaml_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a YAML file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_yaml_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_yaml_config MUST BE AFTER @app.command()\n@dump_yaml_config(\"config_dump_dir/params.yml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def dump_yaml_config(location: FilePath) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for dumping a YAML file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_yaml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_yaml_config MUST BE AFTER @app.command()\n        @dump_yaml_config(\"config_dump_dir/params.yml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=yaml_dumper, location=location)\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_toml_config","title":"dump_toml_config","text":"<pre><code>dump_toml_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a TOML file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_toml_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_toml_config MUST BE AFTER @app.command()\n@dump_toml_config(\"config_dump_dir/params.toml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>src/typer_config/decorators.py</code> <pre><code>def dump_toml_config(location: FilePath) -&gt; TyperCommandDecorator:\n    \"\"\"Decorator for dumping a TOML file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_toml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_toml_config MUST BE AFTER @app.command()\n        @dump_toml_config(\"config_dump_dir/params.toml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=toml_dumper, location=location)\n</code></pre>"},{"location":"api/#typer_config.dumpers","title":"dumpers","text":"<p>Config Dictionary Dumpers.</p>"},{"location":"api/#typer_config.dumpers.json_dumper","title":"json_dumper","text":"<pre><code>json_dumper(config: ConfigDict, location: FilePath) -&gt; None\n</code></pre> <p>Dump config to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required Source code in <code>src/typer_config/dumpers.py</code> <pre><code>def json_dumper(config: ConfigDict, location: FilePath) -&gt; None:\n    \"\"\"Dump config to JSON file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n    \"\"\"\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        json.dump(config, _file)\n</code></pre>"},{"location":"api/#typer_config.dumpers.yaml_dumper","title":"yaml_dumper","text":"<pre><code>yaml_dumper(config: ConfigDict, location: FilePath) -&gt; None\n</code></pre> <p>Dump config to YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>pyyaml is required</p> Source code in <code>src/typer_config/dumpers.py</code> <pre><code>def yaml_dumper(config: ConfigDict, location: FilePath) -&gt; None:\n    \"\"\"Dump config to YAML file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n\n    Raises:\n        ModuleNotFoundError: pyyaml is required\n    \"\"\"\n\n    yaml = try_import(\"yaml\")\n\n    if yaml is None:  # pragma: no cover\n        message = \"Please install the pyyaml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        yaml.dump(config, _file)\n</code></pre>"},{"location":"api/#typer_config.dumpers.toml_dumper","title":"toml_dumper","text":"<pre><code>toml_dumper(config: ConfigDict, location: FilePath) -&gt; None\n</code></pre> <p>Dump config to TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>toml library is required for writing files</p> Source code in <code>src/typer_config/dumpers.py</code> <pre><code>def toml_dumper(config: ConfigDict, location: FilePath) -&gt; None:\n    \"\"\"Dump config to TOML file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n\n    Raises:\n        ModuleNotFoundError: toml library is required for writing files\n    \"\"\"\n\n    toml = try_import(\"toml\")\n\n    if toml is None:  # pragma: no cover\n        message = \"Please install the toml library to write TOML files.\"\n        raise ModuleNotFoundError(message)\n\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        toml.dump(config, _file)\n</code></pre>"},{"location":"api/#typer_config.loaders","title":"loaders","text":"<p>Configuration File Loaders.</p> <p>These loaders must implement the <code>typer_config.__typing.ConfigLoader</code> interface.</p>"},{"location":"api/#typer_config.loaders.loader_transformer","title":"loader_transformer","text":"<pre><code>loader_transformer(\n    loader: ConfigLoader,\n    loader_conditional: Optional[\n        ConfigLoaderConditional\n    ] = None,\n    param_transformer: Optional[\n        TyperParameterValueTransformer\n    ] = None,\n    config_transformer: Optional[\n        ConfigDictTransformer\n    ] = None,\n) -&gt; ConfigLoader\n</code></pre> <p>Configuration loader transformer.</p> <p>This allows to transform the input and output of a configuration loader.</p> <p>Examples:</p> <p>Set a default file to open when none is given: <pre><code>default_file_loader = loader_transformer(\n    yaml_loader,\n    param_transformer=lambda param: param if param else \"config.yml\",\n)\n</code></pre></p> <p>Use a subsection of a file: <pre><code>subsection_loader = loader_transformer(\n    yaml_loader,\n    config_transformer = lambda config: config[\"subsection\"],\n)\n</code></pre></p> <p>Use both transformers to use the <code>[tool.my_tool]</code> section from <code>pyproject.toml</code> by default: <pre><code>pyproject_loader = loader_transformer(\n    toml_loader,\n    param_transformer = lambda param: param if param else \"pyproject.toml\"\n    config_transformer = lambda config: config[\"tool\"][\"my_tool\"],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Loader to transform.</p> required <code>loader_conditional</code> <code>Optional[ConfigLoaderConditional]</code> <p>Function to determine whether to execute loader. Defaults to None (no-op).</p> <code>None</code> <code>param_transformer</code> <code>Optional[TyperParameterValueTransformer]</code> <p>Typer parameter transformer. Defaults to None (no-op).</p> <code>None</code> <code>config_transformer</code> <code>Optional[ConfigDictTransformer]</code> <p>Config dictionary transformer. Defaults to None (no-op).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ConfigLoader</code> <code>ConfigLoader</code> <p>Transformed config loader.</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def loader_transformer(\n    loader: ConfigLoader,\n    loader_conditional: Optional[ConfigLoaderConditional] = None,\n    param_transformer: Optional[TyperParameterValueTransformer] = None,\n    config_transformer: Optional[ConfigDictTransformer] = None,\n) -&gt; ConfigLoader:\n    \"\"\"Configuration loader transformer.\n\n    This allows to transform the input and output of a configuration loader.\n\n    Examples:\n        Set a default file to open when none is given:\n        ```py\n        default_file_loader = loader_transformer(\n            yaml_loader,\n            param_transformer=lambda param: param if param else \"config.yml\",\n        )\n        ```\n\n        Use a subsection of a file:\n        ```py\n        subsection_loader = loader_transformer(\n            yaml_loader,\n            config_transformer = lambda config: config[\"subsection\"],\n        )\n        ```\n\n        Use both transformers to use the `[tool.my_tool]` section from `pyproject.toml`\n        by default:\n        ```py\n        pyproject_loader = loader_transformer(\n            toml_loader,\n            param_transformer = lambda param: param if param else \"pyproject.toml\"\n            config_transformer = lambda config: config[\"tool\"][\"my_tool\"],\n        )\n        ```\n\n    Args:\n        loader (ConfigLoader): Loader to transform.\n        loader_conditional (Optional[ConfigLoaderConditional], optional): Function\n            to determine whether to execute loader. Defaults to None (no-op).\n        param_transformer (Optional[TyperParameterValueTransformer], optional): Typer\n            parameter transformer. Defaults to None (no-op).\n        config_transformer (Optional[ConfigDictTransformer], optional): Config\n            dictionary transformer. Defaults to None (no-op).\n\n    Returns:\n        ConfigLoader: Transformed config loader.\n    \"\"\"\n\n    def _loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n        # Transform input\n        if param_transformer is not None:\n            param_value = param_transformer(param_value)\n\n        # Decide whether to execute loader\n        # NOTE: bad things can happen when `param_value=''`\n        # such as `--help` not working\n        conf: ConfigDict = {}\n        if loader_conditional is None or loader_conditional(param_value):\n            conf = loader(param_value)\n\n        # Transform output\n        if config_transformer is not None:\n            conf = config_transformer(conf)\n\n        return conf\n\n    return _loader\n</code></pre>"},{"location":"api/#typer_config.loaders.yaml_loader","title":"yaml_loader","text":"<pre><code>yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>YAML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of YAML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>pyyaml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"YAML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of YAML file\n\n    Raises:\n        ModuleNotFoundError: pyyaml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    yaml = try_import(\"yaml\")\n\n    if yaml is None:  # pragma: no cover\n        message = \"Please install the pyyaml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = yaml.safe_load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.json_loader","title":"json_loader","text":"<pre><code>json_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>JSON file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of JSON file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def json_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"JSON file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of JSON file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = json.load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.toml_loader","title":"toml_loader","text":"<pre><code>toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>TOML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of TOML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>toml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"TOML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of TOML file\n\n    Raises:\n        ModuleNotFoundError: toml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    # try `tomllib` first\n    tomllib = try_import(\"tomllib\")\n\n    if tomllib is not None:\n        with open(param_value, \"rb\") as _file:\n            return tomllib.load(_file)\n\n    # couldn't find `tommllib`, so try `toml`\n    toml = try_import(\"toml\")\n\n    if toml is None:  # pragma: no cover\n        message = \"Please install the toml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        return toml.load(_file)\n</code></pre>"},{"location":"api/#typer_config.loaders.dotenv_loader","title":"dotenv_loader","text":"<pre><code>dotenv_loader(\n    param_value: TyperParameterValue,\n) -&gt; ConfigDict\n</code></pre> <p>Dotenv file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of Dotenv file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>python-dotenv library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def dotenv_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"Dotenv file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of Dotenv file\n\n    Raises:\n        ModuleNotFoundError: python-dotenv library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    dotenv = try_import(\"dotenv\")\n\n    if dotenv is None:  # pragma: no cover\n        message = \"Please install the python-dotenv library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        # NOTE: I'm using a stream here so that the loader\n        # will raise an exception when the file doesn't exist.\n        conf: ConfigDict = dotenv.dotenv_values(stream=_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.ini_loader","title":"ini_loader","text":"<pre><code>ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>INI file loader.</p> Note <p>INI files must have sections at the top level. You probably want to combine this with <code>loader_transformer</code> to extract the correct section. For example: <pre><code>ini_section_loader = loader_transformer(\n    ini_loader,\n    config_transformer=lambda config: config[\"section\"],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of INI file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n    \"\"\"INI file loader.\n\n    Note:\n        INI files must have sections at the top level.\n        You probably want to combine this with `loader_transformer`\n        to extract the correct section.\n        For example:\n        ```py\n        ini_section_loader = loader_transformer(\n            ini_loader,\n            config_transformer=lambda config: config[\"section\"],\n        )\n        ```\n\n    Args:\n        param_value (TyperParameterValue): path of INI file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    ini_parser = ConfigParser()\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        ini_parser.read_file(_file)\n\n    conf: ConfigDict = {\n        sect: dict(ini_parser.items(sect)) for sect in ini_parser.sections()\n    }\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.multifile_loader","title":"multifile_loader","text":"<pre><code>multifile_loader(\n    files: list[TyperParameterValue],\n    *,\n    skip_missing: bool = True,\n    deep_merge: bool = True\n) -&gt; ConfigDict\n</code></pre> <p>Loader that merges multiple configuration files into one dictionary.</p> <p>Files are processed in order, with later files overriding earlier ones. Missing files are skipped by default.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[TyperParameterValue]</code> <p>List of paths to configuration files.</p> required <code>skip_missing</code> <code>bool</code> <p>Skip files that don't exist. Defaults to True.</p> <code>True</code> <code>deep_merge</code> <code>bool</code> <p>Deep merge nested dictionaries. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>Merged dictionary loaded from all files.</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def multifile_loader(\n    files: list[TyperParameterValue],\n    *,\n    skip_missing: bool = True,\n    deep_merge: bool = True,\n) -&gt; ConfigDict:\n    \"\"\"Loader that merges multiple configuration files into one dictionary.\n\n    Files are processed in order, with later files overriding earlier ones.\n    Missing files are skipped by default.\n\n    Args:\n        files (list[TyperParameterValue]): List of paths to configuration files.\n        skip_missing (bool, optional): Skip files that don't exist.\n            Defaults to True.\n        deep_merge (bool, optional): Deep merge nested dictionaries.\n            Defaults to True.\n\n    Returns:\n        ConfigDict: Merged dictionary loaded from all files.\n    \"\"\"\n    merged_config: ConfigDict = {}\n\n    for file_path in files:\n        if not file_path:\n            continue\n\n        if skip_missing and not Path(file_path).is_file():\n            continue\n\n        loader = _get_loader_for_file(file_path)\n        config = loader(file_path)\n\n        if deep_merge:\n            merged_config = _deep_merge(merged_config, config)\n        else:\n            merged_config.update(config)\n\n    return merged_config\n</code></pre>"},{"location":"api/#typer_config.loaders.multifile_fallback_loader","title":"multifile_fallback_loader","text":"<pre><code>multifile_fallback_loader(\n    files: list[TyperParameterValue],\n) -&gt; ConfigDict\n</code></pre> <p>Loader that uses the first existing configuration file from a list.</p> <p>Files are checked in order. The first file that exists is loaded and returned. This is useful for fallback configurations (e.g., local -&gt; user -&gt; system).</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[TyperParameterValue]</code> <p>List of paths to configuration files, in order of priority (first has highest priority).</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>Dictionary loaded from the first existing file, or empty dict if no files exist.</p> Source code in <code>src/typer_config/loaders.py</code> <pre><code>def multifile_fallback_loader(files: list[TyperParameterValue]) -&gt; ConfigDict:\n    \"\"\"Loader that uses the first existing configuration file from a list.\n\n    Files are checked in order. The first file that exists is loaded and returned.\n    This is useful for fallback configurations (e.g., local -&gt; user -&gt; system).\n\n    Args:\n        files (list[TyperParameterValue]): List of paths to configuration files,\n            in order of priority (first has highest priority).\n\n    Returns:\n        ConfigDict: Dictionary loaded from the first existing file,\n            or empty dict if no files exist.\n    \"\"\"\n    for file_path in files:\n\n        if Path(file_path).is_file():\n            loader = _get_loader_for_file(file_path)\n            return loader(file_path)\n\n    return {}\n</code></pre>"},{"location":"api/#typer_config.utils","title":"utils","text":"<p>Utilities.</p>"},{"location":"api/#typer_config.utils.SimpleWarningFormat","title":"SimpleWarningFormat","text":"<p>Simple Warning Formatter.</p> Source code in <code>src/typer_config/utils.py</code> <pre><code>class SimpleWarningFormat:\n    \"\"\"Simple Warning Formatter.\"\"\"\n\n    def __enter__(self: SimpleWarningFormat) -&gt; None:  # noqa: D105\n        warnings.formatwarning = (  # type: ignore[assignment]\n            lambda msg, category, *args, **kwargs: f\"{category.__name__}: {msg}\\n\"  # noqa: ARG005\n        )\n\n    def __exit__(  # noqa: D105\n        self: SimpleWarningFormat,\n        exc_type: Any,  # noqa: ANN401\n        exc_value: Any,  # noqa: ANN401\n        exc_tb: Any,  # noqa: ANN401\n    ) -&gt; None:\n        warnings.formatwarning = ORIGINAL_WARNING_FORMATTER\n</code></pre>"},{"location":"api/#typer_config.utils.get_dict_section","title":"get_dict_section","text":"<pre><code>get_dict_section(\n    _dict: Dict[Any, Any], keys: Optional[List[Any]] = None\n) -&gt; Dict[Any, Any]\n</code></pre> <p>Get section of a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_dict</code> <code>Dict[str, Any]</code> <p>dictionary to access</p> required <code>keys</code> <code>List[str]</code> <p>list of keys to successively access in the dictionary</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dict[str, Any]: section of dictionary requested</p> Source code in <code>src/typer_config/utils.py</code> <pre><code>def get_dict_section(\n    _dict: Dict[Any, Any], keys: Optional[List[Any]] = None\n) -&gt; Dict[Any, Any]:\n    \"\"\"Get section of a dictionary.\n\n    Args:\n        _dict (Dict[str, Any]): dictionary to access\n        keys (List[str]): list of keys to successively access in the dictionary\n\n    Returns:\n        Dict[str, Any]: section of dictionary requested\n    \"\"\"\n    if keys is not None:\n        for key in keys:\n            _dict = _dict.get(key, {})\n\n    return _dict\n</code></pre>"},{"location":"api/#typer_config.utils.file_exists_and_warn","title":"file_exists_and_warn","text":"<pre><code>file_exists_and_warn(file_path: Union[Path, str]) -&gt; bool\n</code></pre> <p>Check if file exists and warn if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[Path, str]</code> <p>file path to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether file exists</p> Source code in <code>src/typer_config/utils.py</code> <pre><code>def file_exists_and_warn(file_path: Union[Path, str]) -&gt; bool:\n    \"\"\"Check if file exists and warn if it doesn't exist.\n\n    Args:\n        file_path (Union[Path, str]): file path to check\n\n    Returns:\n        bool: whether file exists\n    \"\"\"\n\n    file_path_exists = Path(file_path).is_file()\n\n    if not file_path_exists:\n        msg = f\"No such file: '{file_path}'\"\n\n        with SimpleWarningFormat():\n            showwarning(msg, UserWarning, \"\", 0)\n\n    return file_path_exists\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#151-2026-03-01","title":"1.5.1 - 2026-03-01","text":"<p>Compare with 1.5.0</p>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>improve examples and fix issues across documentation (ea23b1c)</li> <li>replace abstract examples with relatable greeter app (8efa5a6)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks","title":"Miscellaneous Tasks","text":"<ul> <li>add CLAUDE.md for Claude Code guidance (de3755e)</li> </ul>"},{"location":"changelog/#150-2026-02-11","title":"1.5.0 - 2026-02-11","text":"<p>Compare with 1.4.3</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>multifile configs (#383) (0811ae8)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_1","title":"Miscellaneous Tasks","text":"<ul> <li>update pypi classifiers (73acc8a)</li> <li>tooling (#395) (81098f8)</li> </ul>"},{"location":"changelog/#143-2025-10-27","title":"1.4.3 - 2025-10-27","text":"<p>Compare with 1.4.2</p>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>drop python3.9 support (#368) (369582a)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_2","title":"Miscellaneous Tasks","text":"<ul> <li>switch from poetry to uv (#320) (471e738)</li> <li>add python 3.13 test (#321) (8451638)</li> <li>enable dependabot for uv and gh-actions (#323) (6bd60b5)</li> <li>use uv build backend (#334) (aede197)</li> </ul>"},{"location":"changelog/#tools","title":"Tools","text":"<ul> <li>new changelog tool and Makefile (#303) (032204e)</li> </ul>"},{"location":"changelog/#142-2024-11-08","title":"1.4.2 - 2024-11-08","text":"<p>Compare with 1.4.1</p>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>emit warnings when config files are missing (#297) (0e072df)</li> </ul>"},{"location":"changelog/#141-2024-11-07","title":"1.4.1 - 2024-11-07","text":"<p>Compare with 1.4.0</p>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>drop py3.8 (#287) (2321757)</li> <li>future annotations with custom types (#296) (eb2f252)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_3","title":"Miscellaneous Tasks","text":"<ul> <li>formatting (#233) (e1ee1f5)</li> </ul>"},{"location":"changelog/#140-2023-11-17","title":"1.4.0 - 2023-11-17","text":"<p>Compare with 1.3.0</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>list argument callback (#129) (aabeee2)</li> </ul>"},{"location":"changelog/#130-2023-11-06","title":"1.3.0 - 2023-11-06","text":"<p>Compare with 1.2.1</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>default decorator sections (#123) (0b8b8ea)</li> </ul>"},{"location":"changelog/#121-2023-10-12","title":"1.2.1 - 2023-10-12","text":"<p>Compare with 1.2.0</p>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>export use_ini_config in library (d66cb3c)</li> </ul>"},{"location":"changelog/#120-2023-10-12","title":"1.2.0 - 2023-10-12","text":"<p>Compare with 1.1.0</p>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>fix typos (60cd8ea)</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>ini decorator (#102) (80bab13)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_4","title":"Miscellaneous Tasks","text":"<ul> <li>limit CI to run on main and pull requests (3eb2568)</li> <li>release on tags (0e57e8a)</li> <li>remove venv cache (869cde1)</li> </ul>"},{"location":"changelog/#110-2023-08-26","title":"1.1.0 - 2023-08-26","text":"<p>Compare with 1.0.1</p>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>add default values to config decorators (#67) (19d10b7)</li> </ul>"},{"location":"changelog/#101-2023-08-23","title":"1.0.1 - 2023-08-23","text":"<p>Compare with 1.0.0</p>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>add py.typed so mypy will use our annotations (ac56f1c)</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>fix changelog (6177a8e)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_5","title":"Miscellaneous Tasks","text":"<ul> <li>venv cache (#57) (7cbfc08)</li> <li>update blacken-docs (66b9dce)</li> <li>update blacken-docs again (2484e91)</li> </ul>"},{"location":"changelog/#100-2023-07-20","title":"1.0.0 - 2023-07-20","text":"<p>Compare with 0.6.1</p>"},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>fix links and simplify notes (8c8492a)</li> <li>use decorators (f945284)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_6","title":"Miscellaneous Tasks","text":"<ul> <li>remove deprecated code (#45) (e363a80)</li> </ul>"},{"location":"changelog/#deps","title":"Deps","text":"<ul> <li>fix blacken-docs (#43) (e6320e6)</li> </ul>"},{"location":"changelog/#ref","title":"Ref","text":"<ul> <li>ruff linting (#44) (a79245a)</li> </ul>"},{"location":"changelog/#061-2023-07-17","title":"0.6.1 - 2023-07-17","text":"<p>Compare with 0.6.0</p>"},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>use Annotated type (#41) (f2a8a25)</li> </ul>"},{"location":"changelog/#060-2023-07-17","title":"0.6.0 - 2023-07-17","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>update decorator docs (#40) (360e5ef)</li> </ul>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>config decorator (#34) (ae8e44d)</li> <li>dump configuration on invocation (#27) (b2c7b42)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_7","title":"Miscellaneous Tasks","text":"<ul> <li>Create dependabot.yml (388eb7b)</li> <li>fix dependabot.yml (b92cb0d)</li> </ul>"},{"location":"changelog/#deps_1","title":"Deps","text":"<ul> <li>update griffe (e5fc303)</li> </ul>"},{"location":"changelog/#tools_1","title":"Tools","text":"<ul> <li>isort arguments (63279ce)</li> </ul>"},{"location":"changelog/#050-2023-05-25","title":"0.5.0 - 2023-05-25","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>loader conditionals (#23) (4bb82de)</li> </ul>"},{"location":"changelog/#styling","title":"Styling","text":"<ul> <li>isort (85480c0)</li> </ul>"},{"location":"changelog/#040-2023-05-23","title":"0.4.0 - 2023-05-23","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#documentation_6","title":"Documentation","text":"<ul> <li>fix typo (e4d1417)</li> </ul>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>config loader transformer (#21) (7af9695)</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>doc example tests (#22) (cf06503)</li> </ul>"},{"location":"changelog/#030-2023-05-18","title":"0.3.0 - 2023-05-18","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#documentation_7","title":"Documentation","text":"<ul> <li>update docs missing dotenv (23f6734)</li> <li>fix changelog names (75b983d)</li> </ul>"},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>INI support (#17) (2ec9aa5)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_8","title":"Miscellaneous Tasks","text":"<ul> <li>simplify workflow (#18) (17c3af3)</li> </ul>"},{"location":"changelog/#styling_1","title":"Styling","text":"<ul> <li>use google docstrings (#16) (2e2e09f)</li> </ul>"},{"location":"changelog/#ref_1","title":"Ref","text":"<ul> <li>reorder release steps (6f83ed0)</li> </ul>"},{"location":"changelog/#020-2023-05-18","title":"0.2.0 - 2023-05-18","text":"<p>Compare with 0.1.3</p>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>tooling (ae24220)</li> </ul>"},{"location":"changelog/#documentation_8","title":"Documentation","text":"<ul> <li>add shields (8283eb8)</li> <li>update docstrings for default callbacks (c9e1450)</li> <li>fix broken link (2643281)</li> <li>generate changelog for mkdocs (394f286)</li> </ul>"},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>dotenv (#15) (28f5e61)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_9","title":"Miscellaneous Tasks","text":"<ul> <li>tooling (#12) (fc0e5b8)</li> </ul>"},{"location":"changelog/#styling_2","title":"Styling","text":"<ul> <li>fix formatting (17985e4)</li> <li>formatting (e05b7d8)</li> </ul>"},{"location":"changelog/#013-2023-05-15","title":"0.1.3 - 2023-05-15","text":"<p>Compare with 0.1.2</p>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>typo (cca9eb3)</li> <li>typo (b7a10c3)</li> <li>change local type module name to match typer (0c087ff)</li> </ul>"},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>type checking (#4) (d4481fb)</li> <li>add subpath and default value combinators (#6) (d080fe0)</li> <li>add coverage (#7) (a06bdca)</li> <li>mkdocs (#8) (49a0d36)</li> </ul>"},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>add test for pyproject example (#5) (dbbd1b6)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_10","title":"Miscellaneous Tasks","text":"<ul> <li>bump version (0fe8193)</li> </ul>"},{"location":"changelog/#012-2023-05-01","title":"0.1.2 - 2023-05-01","text":"<p>Compare with 0.1.1</p>"},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>typer BadParameter (64868a3)</li> <li>tomllib (15f53a5)</li> <li>linter (8bfeb82)</li> </ul>"},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>initial features (4298289)</li> <li>simple example as test (d59962e)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_11","title":"Miscellaneous Tasks","text":"<ul> <li>bump version (e7aeb35)</li> </ul>"},{"location":"how/","title":"How it works","text":"<p>This library works by mutating the default values in the underlying click context (<code>click.Context.default_map</code>) before the command is executed (see phha/click_config_file). It is essentially overwriting the default values that you specified in your source code. Then, the shell environment variables and CLI parameters are parsed by typer to override the values already set.</p> <p>The <code>@use_config</code> decorator works by modifying your function's signature to include a <code>config</code> parameter with a sane default. The <code>typer</code> library then sees this extended signature and parses/generates the help text for the <code>config</code> parameter. Internally, the decorator then removes the <code>config</code> parameter from the arguments passed to the actual implementation that you wrote. Otherwise, your function would error with an unknown argument.</p> <p>If you use the <code>config</code> parameter directly in your function, you must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first. For example: <pre><code>config: str = typer.Option(\"\", is_eager=True, callback=...)\n</code></pre> If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</p>"},{"location":"install/","title":"Installation","text":"<pre><code>$ pip install typer-config\n</code></pre> <p>Note: Python &gt;= 3.10 is required.</p> <p>Note: this only supports reading json files. See below for more file formats.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>Typer Config provides optional dependency sets to read certain file type:</p> <pre><code>$ pip install typer-config[yaml] # includes pyyaml\n\n$ pip install typer-config[toml] # includes toml\n\n$ pip install typer-config[python-dotenv] # includes python-dotenv\n\n$ pip install typer-config[all] # includes all optional dependencies\n</code></pre>"},{"location":"known_issues/","title":"Known Issues","text":"<p>This is a collection of known issues and workarounds to address them.</p>"},{"location":"known_issues/#argument-list-in-config","title":"Argument list in config","text":"<p>Related GitHub issues: typer-config#117, typer-config#124.</p> <p>Providing values for a list argument in a config file doesn't work out of the box. You must use a custom callback for list arguments to extract the values from the config. Thanks to @jlwhelan28 for the initial solution to this problem. Below is a working example of how to deal with an argument list:</p> arg_list.py<pre><code>from typing import List\nimport typer\nfrom typer_config import use_yaml_config\nfrom typer_config.callbacks import argument_list_callback\n\napp = typer.Typer()\n\n\n@app.command()\n@use_yaml_config()\ndef main(\n    name: str,\n    nicknames: List[str] = typer.Argument(default=None, callback=argument_list_callback),\n    greeting: str = typer.Option(...),\n    suffix: str = typer.Option(\"!\"),\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n    typer.echo(f\"{nicknames}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> config.yml<pre><code># config.yml\ngreeting: \"Hello\"\nsuffix: \"!\"\nname: \"World\"\nnicknames: [\"Globe\", \"Earth\", \"Terra\"]\n</code></pre> Terminal<pre><code>$ python arg_list.py --config config.yml\nHello, World!\n['Globe', 'Earth', 'Terra']\n\n$ python arg_list.py Friend Buddy Pal Mate --config config.yml\nHello, Friend!\n['Buddy', 'Pal', 'Mate']\n</code></pre>"},{"location":"examples/default_config/","title":"Default Config File Example","text":"<p>This example loads a configuration from a default YAML file if <code>--config</code> is not given.</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import use_yaml_config  # other formats available (1)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_yaml_config(default_value=\"config.yml\")\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>This package also provides <code>use_json_config</code>, <code>use_toml_config</code>, <code>use_ini_config</code>, and <code>use_dotenv_config</code> for those file formats. <p>Note that since INI requires a top-level section <code>use_ini_config</code> requires a list of strings that express the path to the section    you wish to use, e.g. <code>@use_ini_config([\"section\", \"subsection\", ...])</code>.</p> </li> </ol> <p>With a config file:</p> config.yml<pre><code>name: World\ngreeting: Hello\nsuffix: \"!\"\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py\nHello, World!\n\n$ python simple_app.py Alice\nHello, Alice!\n\n$ python simple_app.py --greeting Hi\nHi, World!\n\n$ python simple_app.py --config other.yml\nHi, Alice!!\n</code></pre>"},{"location":"examples/dotenv/","title":"Dotenv Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a <code>.env</code> file.</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import use_dotenv_config\n\napp = typer.Typer()\n\n\n@app.command()\n@use_dotenv_config()\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <p>With a config file:</p> config.env<pre><code>name=World\ngreeting=Hello\nsuffix=!\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.env\nHello, World!\n\n$ python simple_app.py --config config.env Alice\nHello, Alice!\n\n$ python simple_app.py --config config.env --greeting Hi\nHi, World!\n</code></pre>"},{"location":"examples/explicit_config/","title":"Explicit Configuration Parameter","text":"<p>Instead of using the <code>@use_config()</code> decorator, you can explicitly add <code>config</code> to your typer command. However, you must include <code>is_eager=True</code>.</p>"},{"location":"examples/explicit_config/#simple-yaml-example","title":"Simple YAML Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file.</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.callbacks import yaml_conf_callback  # other formats available (1)\n\napp = typer.Typer()\n\n\n@app.command()\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n    config: Annotated[\n        str,\n        typer.Option(\n            callback=yaml_conf_callback,\n            is_eager=True,  # THIS IS REALLY IMPORTANT (2)\n        ),\n    ] = \"\",\n):\n    # possibly do something with config\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li> <p>This package also provides <code>json_conf_callback</code>, <code>toml_conf_callback</code>, and <code>dotenv_conf_callback</code> for those file formats.</p> </li> <li> <p>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</p> </li> </ol> <p>With a config file:</p> config.yml<pre><code>name: World\ngreeting: Hello\nsuffix: \"!\"\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.yml\nHello, World!\n\n$ python simple_app.py --config config.yml Alice\nHello, Alice!\n\n$ python simple_app.py --config config.yml --greeting Hi\nHi, World!\n</code></pre>"},{"location":"examples/fallback_config/","title":"Fallback Config Example","text":"<p>This example demonstrates fallback configuration where the first existing config file from a list is used. This is useful when you want to check multiple locations for a config file and use the first one found.</p> <p>This pattern is similar to how tools like Ansible look for <code>ansible.cfg</code>: - Check current directory first - Fall back to user's home directory - Fall back to system-wide config</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import use_fallback_config\n\napp = typer.Typer()\n\n\n@app.command()\n@use_fallback_config(fallback_files=[\"local.yml\", \"default.yml\"])\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <p>With a default config file (local.yml doesn't exist in this example):</p> default.yml<pre><code>name: World\ngreeting: Hello\nsuffix: \"!\"\n</code></pre> <p>Since <code>local.yml</code> doesn't exist, <code>default.yml</code> is used:</p> Terminal<pre><code>$ python simple_app.py\nHello, World!\n\n$ python simple_app.py --greeting Hi\nHi, World!\n</code></pre> <p>Now if we create a local config, it takes priority:</p> local.yml<pre><code>name: Team\ngreeting: Hey\nsuffix: \"!!\"\n</code></pre> Terminal (with local.yml)<pre><code>$ python simple_app.py\nHey, Team!!\n</code></pre> <p>The <code>--config</code> option always takes priority over the fallback list:</p> override.yml<pre><code>name: Boss\ngreeting: Yo\nsuffix: \"!!!\"\n</code></pre> Terminal (with --config)<pre><code>$ python simple_app.py --config override.yml\nYo, Boss!!!\n</code></pre> <p>A real-world example with typical config locations:</p> <pre><code>@app.command()\n@use_fallback_config(fallback_files=[\n    \"./myapp.yml\",                # local project config (highest priority)\n    \"~/.config/myapp/config.yml\", # user config\n    \"/etc/myapp/config.yml\",      # system config (lowest priority)\n])\ndef main(...):\n    ...\n</code></pre>"},{"location":"examples/inheritance_config/","title":"Inheritance Config Example","text":"<p>This example demonstrates configuration inheritance where multiple config files are merged together, with later files overriding earlier ones. Nested dictionaries are deep-merged, preserving keys that aren't explicitly overridden.</p> <p>This is useful for layered configuration like: - System defaults (<code>/etc/myapp.yaml</code>) - User overrides (<code>~/.config/myapp.yaml</code>) - Project-local overrides (<code>./myapp.yaml</code>)</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import use_multifile_config\n\napp = typer.Typer()\n\n\n@app.command()\n@use_multifile_config(default_files=[\"base_config.yml\", \"local_config.yml\"])\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <p>With config files representing different layers:</p> base_config.yml<pre><code>name: World\ngreeting: Hello\nsuffix: \"!\"\n</code></pre> local_config.yml<pre><code>greeting: Hey\n</code></pre> <p>Note that <code>local_config.yml</code> only overrides <code>greeting</code>, while <code>name</code> and <code>suffix</code> are inherited from <code>base_config.yml</code>.</p> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py\nHey, World!\n\n$ python simple_app.py --suffix \"!!\"\nHey, World!!\n\n$ python simple_app.py Alice\nHey, Alice!\n</code></pre> <p>Missing config files are silently skipped, so you can define optional override locations:</p> <pre><code>@app.command()\n@use_multifile_config(default_files=[\n    \"/etc/myapp/config.yml\",      # system defaults (may not exist)\n    \"~/.config/myapp/config.yml\", # user config (may not exist)\n    \"./config.yml\",               # local config (may not exist)\n])\ndef main(...):\n    ...\n</code></pre>"},{"location":"examples/ini/","title":"INI Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from an INI file.</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import use_ini_config\n\napp = typer.Typer()\n\n\n@app.command()\n@use_ini_config([\"section\"])\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <p>With a config file:</p> config.ini<pre><code>[section]\nname = World\ngreeting = Hello\nsuffix = !\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.ini\nHello, World!\n\n$ python simple_app.py --config config.ini Alice\nHello, Alice!\n\n$ python simple_app.py --config config.ini --greeting Hi\nHi, World!\n</code></pre>"},{"location":"examples/pydantic/","title":"Pydantic Validation Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file and uses pydantic to validate the file before continuing.</p> <p>An example typer app: simple_app.py<pre><code>from typing import Any\nfrom typing_extensions import Annotated\n\nfrom pydantic import BaseModel\nimport typer\nfrom typer_config.loaders import yaml_loader\nfrom typer_config.callbacks import conf_callback_factory\nfrom typer_config.decorators import use_config\n\n\nclass AppConfig(BaseModel):\n    name: str\n    greeting: str\n    suffix: str\n\n\ndef validator_loader(param_value: str) -&gt; dict[str, Any]:\n    conf = yaml_loader(param_value)\n    AppConfig.model_validate(conf)  # raises an exception if not valid\n    return conf\n\n\nvalidator_callback = conf_callback_factory(validator_loader)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_config(validator_callback)\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <p>With a config file:</p> config.yml<pre><code>name: World\ngreeting: Hello\nsuffix: \"!\"\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.yml\nHello, World!\n\n$ python simple_app.py --config config.yml Alice\nHello, Alice!\n\n$ python simple_app.py --config config.yml --greeting Hi\nHi, World!\n</code></pre>"},{"location":"examples/pyproject/","title":"Pyproject TOML loader","text":"<p>If you use an unsupported file format or need to do extra processing of the file, you can make your own file loader and construct an appropriate callback.</p> <p>Suppose you want to specify parameters in a section of <code>pyproject.toml</code>:</p> pyproject.toml<pre><code>[tool.my_tool.parameters]\nname = \"World\"\ngreeting = \"Hello\"\nsuffix = \"!\"\n</code></pre> <p>Then, we can read the values in our typer CLI:</p> my_tool.py<pre><code>from typing import Any, Dict\nfrom typing_extensions import Annotated\n\nimport typer\nfrom typer_config import conf_callback_factory\nfrom typer_config.loaders import toml_loader\nfrom typer_config.decorators import use_config\n\n\ndef pyproject_loader(param_value: str) -&gt; Dict[str, Any]:\n    if not param_value:  # set a default path to read from\n        param_value = \"pyproject.toml\"\n    pyproject = toml_loader(param_value)\n    conf = pyproject[\"tool\"][\"my_tool\"][\"parameters\"]\n    return conf\n\n\n### You can define the same loader using the loader_transformer combinator:\n#\n# from typer_config.loaders import loader_transformer\n\n# pyproject_loader = loader_transformer(\n#     toml_loader,\n#     param_transformer=lambda param: param or \"pyproject.toml\",\n#     config_transformer=lambda config: config[\"tool\"][\"my_tool\"][\"parameters\"],\n# )\n\npyproject_callback = conf_callback_factory(pyproject_loader)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_config(pyproject_callback)\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <p>And we get this behavior:</p> <pre><code>$ ls .\nmy_tool.py\nother.toml\npyproject.toml\n\n$ python my_tool.py\nHello, World!\n\n$ python my_tool.py Alice\nHello, Alice!\n\n$ python my_tool.py --config other.toml\nHi, Alice!!\n</code></pre>"},{"location":"examples/save_config/","title":"Save Config Files","text":"<p>This example shows you how save the parameters of the invoked command to a configuration file using the <code>@dump_config</code> decorator which operates on Typer commands (requested in issue #25).</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import (\n    dump_json_config,  # other formats available (1)\n    use_json_config,\n)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_json_config()  # before dump decorator (2)\n@dump_json_config(\"./dumped.json\")\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li> <p>This package also provides <code>@dump_yaml_config</code> and <code>@dump_toml_config</code> for those file formats.</p> </li> <li> <p>If you put <code>@use_json_config</code> before <code>@dump_json_config</code>, you will not capture the <code>config</code> parameter in your config dump. You probably want this behavior to avoid cascading config files.</p> </li> </ol> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --greeting Hello --suffix \"!\" World\nHello, World!\n\n$ cat ./dumped.json\n{\"name\": \"World\", \"greeting\": \"Hello\", \"suffix\": \"!\"}\n</code></pre>"},{"location":"examples/schema/","title":"Schema Validation Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file and uses schema to validate the file before continuing.</p> <p>An example typer app: simple_app.py<pre><code>from typing import Any\nfrom typing_extensions import Annotated\n\nfrom schema import Schema\nimport typer\nfrom typer_config import yaml_loader, conf_callback_factory, use_config\n\nschema = Schema({\"name\": str, \"greeting\": str, \"suffix\": str})\n\n\ndef validator_loader(param_value: str) -&gt; dict[str, Any]:\n    conf = yaml_loader(param_value)\n    conf = schema.validate(conf)  # raises an exception if not valid\n    return conf\n\n\nvalidator_callback = conf_callback_factory(validator_loader)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_config(validator_callback)\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <p>With a config file:</p> config.yml<pre><code>name: World\ngreeting: Hello\nsuffix: \"!\"\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.yml\nHello, World!\n\n$ python simple_app.py --config config.yml Alice\nHello, Alice!\n\n$ python simple_app.py --config config.yml --greeting Hi\nHi, World!\n</code></pre>"},{"location":"examples/simple_yaml/","title":"Simple YAML Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file.</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import use_yaml_config  # other formats available (1)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_yaml_config()\ndef main(\n    name: str,\n    greeting: Annotated[str, typer.Option()],\n    suffix: Annotated[str, typer.Option()] = \"!\",\n):\n    typer.echo(f\"{greeting}, {name}{suffix}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>This package also provides <code>use_json_config</code>, <code>use_toml_config</code>, and <code>use_dotenv_config</code> for those file formats.</li> </ol> <p>With a config file:</p> config.yml<pre><code>name: World\ngreeting: Hello\nsuffix: \"!\"\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.yml\nHello, World!\n\n$ python simple_app.py --config config.yml Alice\nHello, Alice!\n\n$ python simple_app.py --config config.yml --greeting Hi\nHi, World!\n</code></pre>"}]}