{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"typer-config","text":"<p>This is a collection of utilities to use configuration files to set parameters for a typer CLI. It is useful for typer commands with many options/arguments so you don't have to constantly rewrite long commands. This package was inspired by phha/click_config_file and prototyped in this issue. It allows you to set values for CLI parameters using a configuration file. </p> <pre><code># Long commands like this:\n$ my-typer-app --opt1 foo --opt2 bar arg1 arg2\n\n# Can become this:\n$ my-typer-app --config config.yml\n</code></pre> <p>See Examples for more.</p>"},{"location":"api/","title":"typer_config","text":"<p>Typer Configuration Utilities</p>"},{"location":"api/#typer_config.yaml_conf_callback","title":"yaml_conf_callback  <code>module-attribute</code>","text":"<pre><code>yaml_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(yaml_loader)\n)\n</code></pre> <p>YAML configuration callback for a typer parameter.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Returns:</p> Type Description <code>TyperParameterValue</code> <p>must return back the given parameter</p> <p>Raises:</p> Type Description <code>typer.BadParameter</code> <p>bad parameter value</p>"},{"location":"api/#typer_config.json_conf_callback","title":"json_conf_callback  <code>module-attribute</code>","text":"<pre><code>json_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(json_loader)\n)\n</code></pre> <p>JSON configuration callback for a typer parameter.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Returns:</p> Type Description <code>TyperParameterValue</code> <p>must return back the given parameter</p> <p>Raises:</p> Type Description <code>typer.BadParameter</code> <p>bad parameter value</p>"},{"location":"api/#typer_config.toml_conf_callback","title":"toml_conf_callback  <code>module-attribute</code>","text":"<pre><code>toml_conf_callback: ConfigParameterCallback = (\n    conf_callback_factory(toml_loader)\n)\n</code></pre> <p>TOML configuration callback for a typer parameter.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Returns:</p> Type Description <code>TyperParameterValue</code> <p>must return back the given parameter</p> <p>Raises:</p> Type Description <code>typer.BadParameter</code> <p>bad parameter value</p>"},{"location":"api/#typer_config.conf_callback_factory","title":"conf_callback_factory","text":"<pre><code>conf_callback_factory(\n    loader: ConfigLoader,\n) -&gt; ConfigParameterCallback\n</code></pre> <p>Typer configuration callback factory.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Config loader function that takes the value passed to the typer CLI and returns a dictionary that is applied to the click context's default map.</p> required <p>Returns:</p> Type Description <code>ConfigParameterCallback</code> <p>Configuration parameter callback function.</p> Source code in <code>typer_config/__init__.py</code> <pre><code>def conf_callback_factory(loader: ConfigLoader) -&gt; ConfigParameterCallback:\n\"\"\"Typer configuration callback factory.\n\n    Parameters\n    ----------\n    loader : ConfigLoader\n        Config loader function that takes the value passed to the typer CLI and\n        returns a dictionary that is applied to the click context's default map.\n\n    Returns\n    -------\n    ConfigParameterCallback\n        Configuration parameter callback function.\n    \"\"\"\n\n    def _callback(\n        ctx: Context, param: CallbackParam, param_value: TyperParameterValue\n    ) -&gt; TyperParameterValue:\n\"\"\"Generated typer config parameter callback.\n\n        Parameters\n        ----------\n        ctx : typer.Context\n            typer context (automatically passed)\n        param : typer.CallbackParam\n            typer callback parameter (automatically passed)\n        param_value : TyperParameterValue\n            parameter value passed to typer (automatically passed)\n\n        Returns\n        -------\n        TyperParameterValue\n            must return back the given parameter\n\n        Raises\n        ------\n        typer.BadParameter\n            bad parameter value\n        \"\"\"\n        try:\n            conf = loader(param_value)  # Load config file\n            ctx.default_map = ctx.default_map or {}  # Initialize the default map\n            ctx.default_map.update(conf)  # Merge the config Dict into default_map\n        except Exception as ex:\n            raise BadParameter(str(ex), ctx=ctx, param=param) from ex\n        return param_value\n\n    return _callback\n</code></pre>"},{"location":"api/#typer_config.__typing","title":"__typing","text":"<p>Data and Function types.</p>"},{"location":"api/#typer_config.__typing.TyperParameterName","title":"TyperParameterName  <code>module-attribute</code>","text":"<pre><code>TyperParameterName: TypeAlias = str\n</code></pre> <p>Typer CLI parameter name.</p>"},{"location":"api/#typer_config.__typing.TyperParameterValue","title":"TyperParameterValue  <code>module-attribute</code>","text":"<pre><code>TyperParameterValue: TypeAlias = Any\n</code></pre> <p>Typer CLI parameter value.</p>"},{"location":"api/#typer_config.__typing.ConfigDict","title":"ConfigDict  <code>module-attribute</code>","text":"<pre><code>ConfigDict: TypeAlias = Dict[TyperParameterName, Any]\n</code></pre> <p>Configuration dictionary to be applied to the click context default map.</p>"},{"location":"api/#typer_config.__typing.ConfigDictAccessorPath","title":"ConfigDictAccessorPath  <code>module-attribute</code>","text":"<pre><code>ConfigDictAccessorPath: TypeAlias = Iterable[str]\n</code></pre> <p>Configuration dictionary accessor path.</p>"},{"location":"api/#typer_config.__typing.ConfigLoader","title":"ConfigLoader  <code>module-attribute</code>","text":"<pre><code>ConfigLoader: TypeAlias = Callable[\n    [TyperParameterValue], ConfigDict\n]\n</code></pre> <p>Configuration loader function.</p>"},{"location":"api/#typer_config.__typing.ConfigParameterCallback","title":"ConfigParameterCallback  <code>module-attribute</code>","text":"<pre><code>ConfigParameterCallback: TypeAlias = Callable[\n    [Context, CallbackParam, TyperParameterValue],\n    TyperParameterValue,\n]\n</code></pre> <p>Typer config parameter callback function.</p>"},{"location":"api/#typer_config.__typing.NoArgCallable","title":"NoArgCallable  <code>module-attribute</code>","text":"<pre><code>NoArgCallable: TypeAlias = Callable[[], Any]\n</code></pre> <p>No argument callable.</p>"},{"location":"api/#typer_config.loaders","title":"loaders","text":"<p>Configuration File Loaders.</p> <p>These loaders must implement the <code>typer_config.__typing.ConfigLoader</code> interface.</p>"},{"location":"api/#typer_config.loaders.subpath_loader","title":"subpath_loader","text":"<pre><code>subpath_loader(\n    loader: ConfigLoader, dictpath: ConfigDictAccessorPath\n) -&gt; ConfigLoader\n</code></pre> <p>Modify a loader to return a subpath of the dictionary from file.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>loader to modify</p> required <code>dictpath</code> <code>ConfigDictAccessorPath</code> <p>path to the section of the dictionary to return</p> required <p>Returns:</p> Type Description <code>ConfigLoader</code> <p>sub dictionary loader</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def subpath_loader(\n    loader: ConfigLoader, dictpath: ConfigDictAccessorPath\n) -&gt; ConfigLoader:\n\"\"\"Modify a loader to return a subpath of the dictionary from file.\n\n    Parameters\n    ----------\n    loader : ConfigLoader\n        loader to modify\n    dictpath : ConfigDictAccessorPath\n        path to the section of the dictionary to return\n\n    Returns\n    -------\n    ConfigLoader\n        sub dictionary loader\n    \"\"\"\n\n    def _loader(param_value: str) -&gt; ConfigDict:\n        # get original ConfigDict\n        conf: ConfigDict = loader(param_value)\n\n        # get subpath of dictionary\n        for path in dictpath:\n            conf = conf.get(path, {})\n        return conf\n\n    return _loader\n</code></pre>"},{"location":"api/#typer_config.loaders.default_value_loader","title":"default_value_loader","text":"<pre><code>default_value_loader(\n    loader: ConfigLoader, value_getter: NoArgCallable\n) -&gt; ConfigLoader\n</code></pre> <p>Modify a loader to use a default value if the passed value is false-ish</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>loader to modify</p> required <code>value_getter</code> <code>NoArgCallable</code> <p>function that returns default value</p> required <p>Returns:</p> Type Description <code>ConfigLoader</code> <p>modified loader</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def default_value_loader(\n    loader: ConfigLoader, value_getter: NoArgCallable\n) -&gt; ConfigLoader:\n\"\"\"Modify a loader to use a default value if the passed value is false-ish\n\n    Parameters\n    ----------\n    loader : ConfigLoader\n        loader to modify\n    value_getter : NoArgCallable\n        function that returns default value\n\n    Returns\n    -------\n    ConfigLoader\n        modified loader\n    \"\"\"\n\n    def _loader(param_value: str) -&gt; ConfigDict:\n        # parameter value was not specified by user\n        if not param_value:\n            param_value = value_getter()\n\n        conf: ConfigDict = loader(param_value)\n\n        return conf\n\n    return _loader\n</code></pre>"},{"location":"api/#typer_config.loaders.yaml_loader","title":"yaml_loader","text":"<pre><code>yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>YAML file loader</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of YAML file</p> required <p>Returns:</p> Type Description <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"YAML file loader\n\n    Parameters\n    ----------\n    param_value : TyperParameterValue\n        path of YAML file\n\n    Returns\n    -------\n    ConfigDict\n        dictionary loaded from file\n    \"\"\"\n\n    if YAML_MISSING:  # pragma: no cover\n        raise ModuleNotFoundError(\"Please install the pyyaml library.\")\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = yaml.safe_load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.json_loader","title":"json_loader","text":"<pre><code>json_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>JSON file loader</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of JSON file</p> required <p>Returns:</p> Type Description <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def json_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"JSON file loader\n\n    Parameters\n    ----------\n    param_value : TyperParameterValue\n        path of JSON file\n\n    Returns\n    -------\n    ConfigDict\n        dictionary loaded from file\n    \"\"\"\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = json.load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.toml_loader","title":"toml_loader","text":"<pre><code>toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>TOML file loader</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of TOML file</p> required <p>Returns:</p> Type Description <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"TOML file loader\n\n    Parameters\n    ----------\n    param_value : TyperParameterValue\n        path of TOML file\n\n    Returns\n    -------\n    ConfigDict\n        dictionary loaded from file\n    \"\"\"\n\n    if TOML_MISSING:  # pragma: no cover\n        raise ModuleNotFoundError(\"Please install the toml library.\")\n\n    conf: ConfigDict = {}\n\n    if USING_TOMLLIB:  # pragma: no cover\n        with open(param_value, \"rb\") as _file:\n            conf = tomllib.load(_file)  # type: ignore\n    else:  # pragma: no cover\n        with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n            conf = toml.load(_file)  # type: ignore\n\n    return conf\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#013-2023-05-15","title":"0.1.3 - 2023-05-15","text":"<p>Compare with 0.1.2</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>add test for pyproject example (#5) (dbbd1b6 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>change local type module name to match typer (0c087ff by maxb2).</li> <li>typo (b7a10c3 by maxb2).</li> </ul>"},{"location":"changelog/#012-2023-05-01","title":"0.1.2 - 2023-05-01","text":"<p>Compare with first commit</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>simple example as test (d59962e by maxb2).</li> <li>initial features (4298289 by maxb2).</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>linter (8bfeb82 by maxb2).</li> <li>tomllib (15f53a5 by maxb2).</li> <li>typer BadParameter (64868a3 by maxb2).</li> </ul>"},{"location":"how/","title":"How it works","text":"<p>This works by mutating the default values in the underlying click context (<code>click.Context.default_map</code>) before the command is executed (see phha/click_config_file). It is essentially overwriting the default values that you specified in your source code. Then, the shell environment variables and CLI parameters are parsed by typer to override the values already set.</p> <p>Note: You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.   If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</p>"},{"location":"install/","title":"Installation","text":"<pre><code>$ pip install typer-config\n</code></pre> <p>Note: this only supports reading json files. See below for more file formats.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>Typer Config provides optional dependency sets to read certain file type:</p> <pre><code>$ pip install typer-config[yaml] # includes pyyaml\n\n$ pip install typer-config[toml] # includes toml\n\n$ pip install typer-config[all] # includes all optional dependencies\n</code></pre>"},{"location":"examples/pyproject/","title":"Pyproject TOML loader","text":"<p>If you use an unsupported file format or need to do extra processing of the file, you can make your own file loader and construct an appropriate callback.</p> <p>Suppose you want to specify parameters in a section of <code>pyproject.toml</code>:</p> pyproject.toml<pre><code>[tool.my_tool.parameters]\narg1 = \"stuff\"\nopt1 = \"things\"\nopt2 = \"nothing\"\n</code></pre> <p>Then, we can read the values in our typer CLI:</p> my_tool.py<pre><code>from typing import Any, Dict\n\nimport typer\nfrom typer_config import conf_callback_factory\nfrom typer_config.loaders import toml_loader\n\n\ndef pyproject_loader(param_value: str) -&gt; Dict[str, Any]:\n    if not param_value: # set a default path to read from\n        param_value = \"pyproject.toml\"\n\n    pyproject = toml_loader(\"pyproject.toml\")\n    conf = pyproject[\"tool\"][\"my_tool\"][\"parameters\"]\n    return conf\n\n### You can define the same loader using some provided combinators:\n#\n# from typer_config.loaders import default_value_loader, subpath_loader, toml_loader\n# \n# pyproject_loader = subpath_loader(\n#     default_value_loader(toml_loader, lambda: \"pyproject.toml\"),\n#     [\"tool\", \"my_tool\", \"parameters\"],\n# )\n\npyproject_callback = conf_callback_factory(pyproject_loader)\n\napp = typer.Typer( )\n\n@app.command()\ndef main(\n    arg1: str,\n    config: str = typer.Option(\n        \"\",\n        callback=pyproject_callback,\n        is_eager=True,  # THIS IS REALLY IMPORTANT (1)\n    ),\n    opt1: str = typer.Option(...),\n    opt2: str = typer.Option(\"hello\"),\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <ol> <li>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</li> </ol> <p>And we get this behavior:</p> <pre><code>$ ls .\nmy_tool.py other.toml pyproject.toml\n\n$ python my_tool.py\nthings nothing stuff\n\n$ python my_tool.py others\nthings nothing others\n\n$ python my_tool.py --config other.toml\nsomething else entirely\n</code></pre>"},{"location":"examples/simple_yaml/","title":"Simple YAML Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file.</p> <p>An example typer app: simple_app.py<pre><code>import typer\nfrom typer_config import yaml_conf_callback\n\napp = typer.Typer( )\n\n@app.command()\ndef main(\n    arg1: str,\n    config: str = typer.Option(\n        \"\",\n        callback=yaml_conf_callback,\n        is_eager=True,  # THIS IS REALLY IMPORTANT (1)\n    ),\n    opt1: str = typer.Option(...),\n    opt2: str = typer.Option(\"hello\"),\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</li> </ol> <p>With a config file:</p> config.yaml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> <pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre> <p>Note: this package also provides <code>json_conf_callback</code> and <code>toml_conf_callback</code> for those file formats.</p>"}]}