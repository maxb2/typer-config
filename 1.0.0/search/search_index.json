{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"typer-config","text":"<p>This is a collection of utilities to use configuration files to set parameters for a typer CLI. It is useful for typer commands with many options/arguments so you don't have to constantly rewrite long commands. This package was inspired by phha/click_config_file and prototyped in this issue. It allows you to set values for CLI parameters using a configuration file. </p> <pre><code># Long commands like this:\n$ my-typer-app --opt1 foo --opt2 bar arg1 arg2\n\n# Can become this:\n$ my-typer-app --config config.yml\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>You can use a decorator to quickly add a configuration parameter to your <code>typer</code> application:</p> <pre><code>import typer\nfrom typer_config import use_yaml_config # other formats available (1)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_yaml_config() # MUST BE AFTER @app.command() (2)\ndef main(...):\n    ...\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <ol> <li> <p>This package also provides <code>@use_json_config</code>, <code>@use_toml_config</code>, and <code>@use_dotenv_config</code> for those file formats.    You can also use your own loader function and the <code>@use_config(loader_func)</code> decorator.</p> </li> <li> <p>The <code>app.command()</code> decorator registers the function object in a lookup table, so we must transform our command before registration.</p> </li> </ol> <p>Your typer command will now include a <code>--config CONFIG_FILE</code> option at the command line.</p> <p>See Examples for more use cases.</p>"},{"location":"api/","title":"typer_config","text":"<p>Typer Configuration Utilities.</p>"},{"location":"api/#typer_config.yaml_conf_callback","title":"yaml_conf_callback  <code>module-attribute</code>","text":"<pre><code>yaml_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        yaml_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>YAML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.json_conf_callback","title":"json_conf_callback  <code>module-attribute</code>","text":"<pre><code>json_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        json_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>JSON typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.toml_conf_callback","title":"toml_conf_callback  <code>module-attribute</code>","text":"<pre><code>toml_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        toml_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>TOML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.dotenv_conf_callback","title":"dotenv_conf_callback  <code>module-attribute</code>","text":"<pre><code>dotenv_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        dotenv_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>Dotenv typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.conf_callback_factory","title":"conf_callback_factory","text":"<pre><code>conf_callback_factory(\n    loader: ConfigLoader,\n) -&gt; ConfigParameterCallback\n</code></pre> <p>Typer configuration callback factory.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Config loader function that takes the value passed to the typer CLI and returns a dictionary that is applied to the click context's default map.</p> required <p>Returns:</p> Name Type Description <code>ConfigParameterCallback</code> <code>ConfigParameterCallback</code> <p>Configuration parameter callback function.</p> Source code in <code>typer_config/callbacks.py</code> <pre><code>def conf_callback_factory(loader: ConfigLoader) -&gt; ConfigParameterCallback:\n\"\"\"Typer configuration callback factory.\n\n    Args:\n        loader (ConfigLoader): Config loader function that takes the value\n            passed to the typer CLI and returns a dictionary that is\n            applied to the click context's default map.\n\n    Returns:\n        ConfigParameterCallback: Configuration parameter callback function.\n    \"\"\"\n\n    def _callback(\n        ctx: Context, param: CallbackParam, param_value: TyperParameterValue\n    ) -&gt; TyperParameterValue:\n\"\"\"Generated typer config parameter callback.\n\n        Args:\n            ctx (typer.Context): typer context (automatically passed)\n            param (typer.CallbackParam): typer callback parameter (automatically passed)\n            param_value (TyperParameterValue): parameter value passed to typer\n                (automatically passed)\n\n        Raises:\n            BadParameter: bad parameter value\n\n        Returns:\n            TyperParameterValue: must return back the given parameter\n        \"\"\"\n        try:\n            conf = loader(param_value)  # Load config file\n            ctx.default_map = ctx.default_map or {}  # Initialize the default map\n            ctx.default_map.update(conf)  # Merge the config Dict into default_map\n        except Exception as ex:  # noqa: BLE001 (reraising to typer framework)\n            raise BadParameter(str(ex), ctx=ctx, param=param) from ex\n        return param_value\n\n    return _callback\n</code></pre>"},{"location":"api/#typer_config.use_config","title":"use_config","text":"<pre><code>use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_config\nfrom typer_config import yaml_conf_callback # whichever callback to use\n\napp = typer.Typer()\n\n@app.command()\n@use_config(yaml_conf_callback)\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>ConfigParameterCallback</code> <p>config parameter callback to load</p> required <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_config\n        from typer_config import yaml_conf_callback # whichever callback to use\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_config(yaml_conf_callback)\n        def main(...):\n            ...\n        ```\n\n    Args:\n        callback (ConfigParameterCallback): config parameter callback to load\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    def decorator(cmd: TyperCommand) -&gt; TyperCommand:\n        # NOTE: modifying a function's __signature__ is dangerous\n        # in the sense that it only affects inspect.signature().\n        # It does not affect the actual function implementation.\n        # So, a caller can be confused how to pass parameters to\n        # the function with modified signature.\n        sig = signature(cmd)\n\n        config_param = Parameter(\n            param_name,\n            kind=Parameter.KEYWORD_ONLY,\n            annotation=str,\n            default=Option(\"\", callback=callback, is_eager=True, help=param_help),\n        )\n\n        new_sig = sig.replace(parameters=[*sig.parameters.values(), config_param])\n\n        @wraps(cmd)\n        def wrapped(*args, **kwargs):  # noqa: ANN202,ANN002,ANN003\n            # NOTE: need to delete the config parameter\n            # to match the wrapped command's signature.\n            if param_name in kwargs:\n                del kwargs[param_name]\n\n            return cmd(*args, **kwargs)\n\n        wrapped.__signature__ = new_sig  # type: ignore\n\n        return wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/#typer_config.yaml_loader","title":"yaml_loader","text":"<pre><code>yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>YAML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of YAML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>pyyaml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"YAML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of YAML file\n\n    Raises:\n        ModuleNotFoundError: pyyaml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    yaml = try_import(\"yaml\")\n\n    if yaml is None:  # pragma: no cover\n        message = \"Please install the pyyaml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = yaml.safe_load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.use_json_config","title":"use_json_config","text":"<pre><code>use_json_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using JSON configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_json_config\n\napp = typer.Typer()\n\n@app.command()\n@use_json_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_json_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using JSON configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_json_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_json_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=json_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.json_loader","title":"json_loader","text":"<pre><code>json_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>JSON file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of JSON file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def json_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"JSON file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of JSON file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = json.load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.use_yaml_config","title":"use_yaml_config","text":"<pre><code>use_yaml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using YAML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_yaml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_yaml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_yaml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using YAML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_yaml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_yaml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=yaml_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.toml_loader","title":"toml_loader","text":"<pre><code>toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>TOML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of TOML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>toml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"TOML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of TOML file\n\n    Raises:\n        ModuleNotFoundError: toml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    # try `tomllib` first\n    tomllib = try_import(\"tomllib\")\n\n    if tomllib is not None:\n        with open(param_value, \"rb\") as _file:\n            return tomllib.load(_file)\n\n    # couldn't find `tommllib`, so try `toml`\n    toml = try_import(\"toml\")\n\n    if toml is None:  # pragma: no cover\n        message = \"Please install the toml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        return toml.load(_file)\n</code></pre>"},{"location":"api/#typer_config.use_toml_config","title":"use_toml_config","text":"<pre><code>use_toml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using TOML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_toml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_toml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_toml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using TOML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_toml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_toml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=toml_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.dotenv_loader","title":"dotenv_loader","text":"<pre><code>dotenv_loader(\n    param_value: TyperParameterValue,\n) -&gt; ConfigDict\n</code></pre> <p>Dotenv file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of Dotenv file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>python-dotenv library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def dotenv_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"Dotenv file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of Dotenv file\n\n    Raises:\n        ModuleNotFoundError: python-dotenv library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    dotenv = try_import(\"dotenv\")\n\n    if dotenv is None:  # pragma: no cover\n        message = \"Please install the python-dotenv library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        # NOTE: I'm using a stream here so that the loader\n        # will raise an exception when the file doesn't exist.\n        conf: ConfigDict = dotenv.dotenv_values(stream=_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.ini_loader","title":"ini_loader","text":"<pre><code>ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>INI file loader.</p> Note <p>INI files must have sections at the top level. You probably want to combine this with <code>subpath_loader</code>. For example: <pre><code>ini_section_loader = subpath_loader(ini_loader, [\"section\"])\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of INI file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"INI file loader.\n\n    Note:\n        INI files must have sections at the top level.\n        You probably want to combine this with `subpath_loader`.\n        For example:\n        ```py\n        ini_section_loader = subpath_loader(ini_loader, [\"section\"])\n        ```\n\n    Args:\n        param_value (TyperParameterValue): path of INI file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    ini_parser = ConfigParser()\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        ini_parser.read_file(_file)\n\n    conf: ConfigDict = {\n        sect: dict(ini_parser.items(sect)) for sect in ini_parser.sections()\n    }\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders","title":"loaders","text":"<p>Configuration File Loaders.</p> <p>These loaders must implement the <code>typer_config.__typing.ConfigLoader</code> interface.</p>"},{"location":"api/#typer_config.loaders.loader_transformer","title":"loader_transformer","text":"<pre><code>loader_transformer(\n    loader: ConfigLoader,\n    loader_conditional: Optional[\n        ConfigLoaderConditional\n    ] = None,\n    param_transformer: Optional[\n        TyperParameterValueTransformer\n    ] = None,\n    config_transformer: Optional[\n        ConfigDictTransformer\n    ] = None,\n) -&gt; ConfigLoader\n</code></pre> <p>Configuration loader transformer.</p> <p>This allows to transform the input and output of a configuration loader.</p> <p>Examples:</p> <p>Set a default file to open when none is given: <pre><code>default_file_loader = loader_transformer(\n    yaml_loader,\n    param_transformer=lambda param: param if param else \"config.yml\",\n)\n</code></pre></p> <p>Use a subsection of a file: <pre><code>subsection_loader = loader_transformer(\n    yaml_loader,\n    config_transformer = lambda config: config[\"subsection\"],\n)\n</code></pre></p> <p>Use both transformers to use the <code>[tool.my_tool]</code> section from <code>pyproject.toml</code> by default: <pre><code>pyproject_loader = loader_transformer(\n    toml_loader,\n    param_transformer = lambda param: param if param else \"pyproject.toml\"\n    config_transformer = lambda config: config[\"tool\"][\"my_tool\"],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Loader to transform.</p> required <code>loader_conditional</code> <code>Optional[ConfigLoaderConditional]</code> <p>Function to determine whether to execute loader. Defaults to None (no-op).</p> <code>None</code> <code>param_transformer</code> <code>Optional[TyperParameterValueTransformer]</code> <p>Typer parameter transformer. Defaults to None (no-op).</p> <code>None</code> <code>config_transformer</code> <code>Optional[ConfigDictTransformer]</code> <p>Config dictionary transformer. Defaults to None (no-op).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ConfigLoader</code> <code>ConfigLoader</code> <p>Transformed config loader.</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def loader_transformer(\n    loader: ConfigLoader,\n    loader_conditional: Optional[ConfigLoaderConditional] = None,\n    param_transformer: Optional[TyperParameterValueTransformer] = None,\n    config_transformer: Optional[ConfigDictTransformer] = None,\n) -&gt; ConfigLoader:\n\"\"\"Configuration loader transformer.\n\n    This allows to transform the input and output of a configuration loader.\n\n    Examples:\n        Set a default file to open when none is given:\n        ```py\n        default_file_loader = loader_transformer(\n            yaml_loader,\n            param_transformer=lambda param: param if param else \"config.yml\",\n        )\n        ```\n\n        Use a subsection of a file:\n        ```py\n        subsection_loader = loader_transformer(\n            yaml_loader,\n            config_transformer = lambda config: config[\"subsection\"],\n        )\n        ```\n\n        Use both transformers to use the `[tool.my_tool]` section from `pyproject.toml`\n        by default:\n        ```py\n        pyproject_loader = loader_transformer(\n            toml_loader,\n            param_transformer = lambda param: param if param else \"pyproject.toml\"\n            config_transformer = lambda config: config[\"tool\"][\"my_tool\"],\n        )\n        ```\n\n    Args:\n        loader (ConfigLoader): Loader to transform.\n        loader_conditional (Optional[ConfigLoaderConditional], optional): Function\n            to determine whether to execute loader. Defaults to None (no-op).\n        param_transformer (Optional[TyperParameterValueTransformer], optional): Typer\n            parameter transformer. Defaults to None (no-op).\n        config_transformer (Optional[ConfigDictTransformer], optional): Config\n            dictionary transformer. Defaults to None (no-op).\n\n    Returns:\n        ConfigLoader: Transformed config loader.\n    \"\"\"\n\n    def _loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n        # Transform input\n        if param_transformer is not None:\n            param_value = param_transformer(param_value)\n\n        # Decide whether to execute loader\n        # NOTE: bad things can happen when `param_value=''`\n        # such as `--help` not working\n        conf: ConfigDict = {}\n        if loader_conditional is None or loader_conditional(param_value):\n            conf = loader(param_value)\n\n        # Transform output\n        if config_transformer is not None:\n            conf = config_transformer(conf)\n\n        return conf\n\n    return _loader\n</code></pre>"},{"location":"api/#typer_config.loaders.yaml_loader","title":"yaml_loader","text":"<pre><code>yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>YAML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of YAML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>pyyaml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"YAML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of YAML file\n\n    Raises:\n        ModuleNotFoundError: pyyaml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    yaml = try_import(\"yaml\")\n\n    if yaml is None:  # pragma: no cover\n        message = \"Please install the pyyaml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = yaml.safe_load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.json_loader","title":"json_loader","text":"<pre><code>json_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>JSON file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of JSON file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def json_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"JSON file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of JSON file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = json.load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.toml_loader","title":"toml_loader","text":"<pre><code>toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>TOML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of TOML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>toml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"TOML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of TOML file\n\n    Raises:\n        ModuleNotFoundError: toml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    # try `tomllib` first\n    tomllib = try_import(\"tomllib\")\n\n    if tomllib is not None:\n        with open(param_value, \"rb\") as _file:\n            return tomllib.load(_file)\n\n    # couldn't find `tommllib`, so try `toml`\n    toml = try_import(\"toml\")\n\n    if toml is None:  # pragma: no cover\n        message = \"Please install the toml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        return toml.load(_file)\n</code></pre>"},{"location":"api/#typer_config.loaders.dotenv_loader","title":"dotenv_loader","text":"<pre><code>dotenv_loader(\n    param_value: TyperParameterValue,\n) -&gt; ConfigDict\n</code></pre> <p>Dotenv file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of Dotenv file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>python-dotenv library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def dotenv_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"Dotenv file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of Dotenv file\n\n    Raises:\n        ModuleNotFoundError: python-dotenv library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    dotenv = try_import(\"dotenv\")\n\n    if dotenv is None:  # pragma: no cover\n        message = \"Please install the python-dotenv library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        # NOTE: I'm using a stream here so that the loader\n        # will raise an exception when the file doesn't exist.\n        conf: ConfigDict = dotenv.dotenv_values(stream=_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.ini_loader","title":"ini_loader","text":"<pre><code>ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>INI file loader.</p> Note <p>INI files must have sections at the top level. You probably want to combine this with <code>subpath_loader</code>. For example: <pre><code>ini_section_loader = subpath_loader(ini_loader, [\"section\"])\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of INI file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"INI file loader.\n\n    Note:\n        INI files must have sections at the top level.\n        You probably want to combine this with `subpath_loader`.\n        For example:\n        ```py\n        ini_section_loader = subpath_loader(ini_loader, [\"section\"])\n        ```\n\n    Args:\n        param_value (TyperParameterValue): path of INI file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    ini_parser = ConfigParser()\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        ini_parser.read_file(_file)\n\n    conf: ConfigDict = {\n        sect: dict(ini_parser.items(sect)) for sect in ini_parser.sections()\n    }\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.callbacks","title":"callbacks","text":"<p>Typer Configuration Parameter Callbacks.</p>"},{"location":"api/#typer_config.callbacks.yaml_conf_callback","title":"yaml_conf_callback  <code>module-attribute</code>","text":"<pre><code>yaml_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        yaml_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>YAML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.json_conf_callback","title":"json_conf_callback  <code>module-attribute</code>","text":"<pre><code>json_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        json_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>JSON typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.toml_conf_callback","title":"toml_conf_callback  <code>module-attribute</code>","text":"<pre><code>toml_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        toml_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>TOML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.dotenv_conf_callback","title":"dotenv_conf_callback  <code>module-attribute</code>","text":"<pre><code>dotenv_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        dotenv_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>Dotenv typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.conf_callback_factory","title":"conf_callback_factory","text":"<pre><code>conf_callback_factory(\n    loader: ConfigLoader,\n) -&gt; ConfigParameterCallback\n</code></pre> <p>Typer configuration callback factory.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Config loader function that takes the value passed to the typer CLI and returns a dictionary that is applied to the click context's default map.</p> required <p>Returns:</p> Name Type Description <code>ConfigParameterCallback</code> <code>ConfigParameterCallback</code> <p>Configuration parameter callback function.</p> Source code in <code>typer_config/callbacks.py</code> <pre><code>def conf_callback_factory(loader: ConfigLoader) -&gt; ConfigParameterCallback:\n\"\"\"Typer configuration callback factory.\n\n    Args:\n        loader (ConfigLoader): Config loader function that takes the value\n            passed to the typer CLI and returns a dictionary that is\n            applied to the click context's default map.\n\n    Returns:\n        ConfigParameterCallback: Configuration parameter callback function.\n    \"\"\"\n\n    def _callback(\n        ctx: Context, param: CallbackParam, param_value: TyperParameterValue\n    ) -&gt; TyperParameterValue:\n\"\"\"Generated typer config parameter callback.\n\n        Args:\n            ctx (typer.Context): typer context (automatically passed)\n            param (typer.CallbackParam): typer callback parameter (automatically passed)\n            param_value (TyperParameterValue): parameter value passed to typer\n                (automatically passed)\n\n        Raises:\n            BadParameter: bad parameter value\n\n        Returns:\n            TyperParameterValue: must return back the given parameter\n        \"\"\"\n        try:\n            conf = loader(param_value)  # Load config file\n            ctx.default_map = ctx.default_map or {}  # Initialize the default map\n            ctx.default_map.update(conf)  # Merge the config Dict into default_map\n        except Exception as ex:  # noqa: BLE001 (reraising to typer framework)\n            raise BadParameter(str(ex), ctx=ctx, param=param) from ex\n        return param_value\n\n    return _callback\n</code></pre>"},{"location":"api/#typer_config.__optional_imports","title":"__optional_imports","text":"<p>Handle optional imports.</p>"},{"location":"api/#typer_config.__optional_imports.try_import","title":"try_import  <code>cached</code>","text":"<pre><code>try_import(module_name: str)\n</code></pre> <p>Try to import a module by name.</p> <p>Note: caches the imported modules in a <code>functools.lru_cache</code></p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>name of module to import</p> required <p>Returns:</p> Name Type Description <code>Module</code> <p>imported module</p> Source code in <code>typer_config/__optional_imports.py</code> <pre><code>@lru_cache()\ndef try_import(module_name: str):  # noqa: ANN202 (no type for modules)\n\"\"\"Try to import a module by name.\n\n    Note: caches the imported modules in a `functools.lru_cache`\n\n    Args:\n        module_name (str): name of module to import\n\n    Returns:\n        Module: imported module\n    \"\"\"\n    if find_spec(module_name):\n        return import_module(module_name)\n    return None\n</code></pre>"},{"location":"api/#typer_config.__typing","title":"__typing","text":"<p>Data and Function types.</p>"},{"location":"api/#typer_config.__typing.TyperParameterName","title":"TyperParameterName  <code>module-attribute</code>","text":"<pre><code>TyperParameterName: TypeAlias = str\n</code></pre> <p>Typer CLI parameter name.</p>"},{"location":"api/#typer_config.__typing.TyperParameterValue","title":"TyperParameterValue  <code>module-attribute</code>","text":"<pre><code>TyperParameterValue: TypeAlias = Any\n</code></pre> <p>Typer CLI parameter value.</p>"},{"location":"api/#typer_config.__typing.ConfigDict","title":"ConfigDict  <code>module-attribute</code>","text":"<pre><code>ConfigDict: TypeAlias = Dict[TyperParameterName, Any]\n</code></pre> <p>Configuration dictionary to be applied to the click context default map.</p>"},{"location":"api/#typer_config.__typing.FilePath","title":"FilePath  <code>module-attribute</code>","text":"<pre><code>FilePath: TypeAlias = Union[Path, str]\n</code></pre> <p>File path</p>"},{"location":"api/#typer_config.__typing.TyperParameterValueTransformer","title":"TyperParameterValueTransformer  <code>module-attribute</code>","text":"<pre><code>TyperParameterValueTransformer: TypeAlias = Callable[\n    [TyperParameterValue], TyperParameterValue\n]\n</code></pre> <p>Typer parameter value transforming function.</p>"},{"location":"api/#typer_config.__typing.ConfigDictTransformer","title":"ConfigDictTransformer  <code>module-attribute</code>","text":"<pre><code>ConfigDictTransformer: TypeAlias = Callable[\n    [ConfigDict], ConfigDict\n]\n</code></pre> <p>ConfigDict transforming function.</p>"},{"location":"api/#typer_config.__typing.ConfigLoader","title":"ConfigLoader  <code>module-attribute</code>","text":"<pre><code>ConfigLoader: TypeAlias = Callable[\n    [TyperParameterValue], ConfigDict\n]\n</code></pre> <p>Configuration loader function.</p>"},{"location":"api/#typer_config.__typing.ConfigLoaderConditional","title":"ConfigLoaderConditional  <code>module-attribute</code>","text":"<pre><code>ConfigLoaderConditional: TypeAlias = Callable[\n    [TyperParameterValue], bool\n]\n</code></pre> <p>Configuration loader conditional function.</p>"},{"location":"api/#typer_config.__typing.ConfigParameterCallback","title":"ConfigParameterCallback  <code>module-attribute</code>","text":"<pre><code>ConfigParameterCallback: TypeAlias = Callable[\n    [Context, CallbackParam, TyperParameterValue],\n    TyperParameterValue,\n]\n</code></pre> <p>Typer config parameter callback function.</p>"},{"location":"api/#typer_config.__typing.ConfigDumper","title":"ConfigDumper  <code>module-attribute</code>","text":"<pre><code>ConfigDumper: TypeAlias = Callable[\n    [ConfigDict, FilePath], None\n]\n</code></pre> <p>Configuration dumper function.</p>"},{"location":"api/#typer_config.__typing.TyperCommand","title":"TyperCommand  <code>module-attribute</code>","text":"<pre><code>TyperCommand: TypeAlias = Callable[..., Any]\n</code></pre> <p>A function that will be decorated with <code>typer.Typer().command()</code>.</p>"},{"location":"api/#typer_config.__typing.TyperCommandDecorator","title":"TyperCommandDecorator  <code>module-attribute</code>","text":"<pre><code>TyperCommandDecorator: TypeAlias = Callable[\n    [TyperCommand], TyperCommand\n]\n</code></pre> <p>A decorator applied to a typer command.</p>"},{"location":"api/#typer_config.decorators","title":"decorators","text":"<p>Typer Config decorators.</p>"},{"location":"api/#typer_config.decorators.use_config","title":"use_config","text":"<pre><code>use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_config\nfrom typer_config import yaml_conf_callback # whichever callback to use\n\napp = typer.Typer()\n\n@app.command()\n@use_config(yaml_conf_callback)\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>ConfigParameterCallback</code> <p>config parameter callback to load</p> required <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_config\n        from typer_config import yaml_conf_callback # whichever callback to use\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_config(yaml_conf_callback)\n        def main(...):\n            ...\n        ```\n\n    Args:\n        callback (ConfigParameterCallback): config parameter callback to load\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    def decorator(cmd: TyperCommand) -&gt; TyperCommand:\n        # NOTE: modifying a function's __signature__ is dangerous\n        # in the sense that it only affects inspect.signature().\n        # It does not affect the actual function implementation.\n        # So, a caller can be confused how to pass parameters to\n        # the function with modified signature.\n        sig = signature(cmd)\n\n        config_param = Parameter(\n            param_name,\n            kind=Parameter.KEYWORD_ONLY,\n            annotation=str,\n            default=Option(\"\", callback=callback, is_eager=True, help=param_help),\n        )\n\n        new_sig = sig.replace(parameters=[*sig.parameters.values(), config_param])\n\n        @wraps(cmd)\n        def wrapped(*args, **kwargs):  # noqa: ANN202,ANN002,ANN003\n            # NOTE: need to delete the config parameter\n            # to match the wrapped command's signature.\n            if param_name in kwargs:\n                del kwargs[param_name]\n\n            return cmd(*args, **kwargs)\n\n        wrapped.__signature__ = new_sig  # type: ignore\n\n        return wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/#typer_config.decorators.use_json_config","title":"use_json_config","text":"<pre><code>use_json_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using JSON configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_json_config\n\napp = typer.Typer()\n\n@app.command()\n@use_json_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_json_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using JSON configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_json_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_json_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=json_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.decorators.use_yaml_config","title":"use_yaml_config","text":"<pre><code>use_yaml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using YAML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_yaml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_yaml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_yaml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using YAML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_yaml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_yaml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=yaml_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.decorators.use_toml_config","title":"use_toml_config","text":"<pre><code>use_toml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using TOML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_toml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_toml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_toml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using TOML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_toml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_toml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=toml_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.decorators.use_dotenv_config","title":"use_dotenv_config","text":"<pre><code>use_dotenv_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using dotenv configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_dotenv_config\n\napp = typer.Typer()\n\n@app.command()\n@use_dotenv_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_dotenv_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using dotenv configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_dotenv_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_dotenv_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=dotenv_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_config","title":"dump_config","text":"<pre><code>dump_config(\n    dumper: ConfigDumper, location: FilePath\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a config file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_config MUST BE AFTER @app.command()\n@dump_config(yaml_dumper, \"config_dump_dir/params.yaml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>ConfigDumper</code> <p>config file dumper</p> required <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def dump_config(dumper: ConfigDumper, location: FilePath) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for dumping a config file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_config MUST BE AFTER @app.command()\n        @dump_config(yaml_dumper, \"config_dump_dir/params.yaml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        dumper (ConfigDumper): config file dumper\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n\n    def decorator(cmd: TyperCommand) -&gt; TyperCommand:\n        @wraps(cmd)\n        def inner(*args, **kwargs):  # noqa: ANN202,ANN002,ANN003\n            # get a dictionary of the passed args\n            bound_args = signature(cmd).bind(*args, **kwargs).arguments\n\n            # convert enums to their values\n            # NOTE: bound_args shouldn't be nested in the typer\n            # framework, so top level iteration should be fine.\n            for key, val in bound_args.items():\n                if isinstance(val, Enum):\n                    bound_args[key] = val.value\n\n            # dump passed args\n            dumper(bound_args, location)\n\n            # run original command\n            return cmd(*args, **kwargs)\n\n        return inner\n\n    return decorator\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_json_config","title":"dump_json_config","text":"<pre><code>dump_json_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a JSON file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_json_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_json_config MUST BE AFTER @app.command()\n@dump_json_config(\"config_dump_dir/params.json\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def dump_json_config(location: FilePath) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for dumping a JSON file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_json_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_json_config MUST BE AFTER @app.command()\n        @dump_json_config(\"config_dump_dir/params.json\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=json_dumper, location=location)\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_yaml_config","title":"dump_yaml_config","text":"<pre><code>dump_yaml_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a YAML file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_yaml_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_yaml_config MUST BE AFTER @app.command()\n@dump_yaml_config(\"config_dump_dir/params.yml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def dump_yaml_config(location: FilePath) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for dumping a YAML file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_yaml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_yaml_config MUST BE AFTER @app.command()\n        @dump_yaml_config(\"config_dump_dir/params.yml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=yaml_dumper, location=location)\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_toml_config","title":"dump_toml_config","text":"<pre><code>dump_toml_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a TOML file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_toml_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_toml_config MUST BE AFTER @app.command()\n@dump_toml_config(\"config_dump_dir/params.toml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def dump_toml_config(location: FilePath) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for dumping a TOML file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_toml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_toml_config MUST BE AFTER @app.command()\n        @dump_toml_config(\"config_dump_dir/params.toml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=toml_dumper, location=location)\n</code></pre>"},{"location":"api/#typer_config.dumpers","title":"dumpers","text":"<p>Config Dictionary Dumpers.</p>"},{"location":"api/#typer_config.dumpers.json_dumper","title":"json_dumper","text":"<pre><code>json_dumper(config: ConfigDict, location: FilePath) -&gt; None\n</code></pre> <p>Dump config to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required Source code in <code>typer_config/dumpers.py</code> <pre><code>def json_dumper(config: ConfigDict, location: FilePath) -&gt; None:\n\"\"\"Dump config to JSON file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n    \"\"\"\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        json.dump(config, _file)\n</code></pre>"},{"location":"api/#typer_config.dumpers.yaml_dumper","title":"yaml_dumper","text":"<pre><code>yaml_dumper(config: ConfigDict, location: FilePath) -&gt; None\n</code></pre> <p>Dump config to YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>pyyaml is required</p> Source code in <code>typer_config/dumpers.py</code> <pre><code>def yaml_dumper(config: ConfigDict, location: FilePath) -&gt; None:\n\"\"\"Dump config to YAML file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n\n    Raises:\n        ModuleNotFoundError: pyyaml is required\n    \"\"\"\n\n    yaml = try_import(\"yaml\")\n\n    if yaml is None:  # pragma: no cover\n        message = \"Please install the pyyaml library.\"\n        raise ModuleNotFoundError(message)\n\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        # NOTE: we must convert config from OrderedDict to dict because\n        # pyyaml can't load OrderedDict for python &lt;= 3.8\n        yaml.dump(dict(config), _file)\n</code></pre>"},{"location":"api/#typer_config.dumpers.toml_dumper","title":"toml_dumper","text":"<pre><code>toml_dumper(config: ConfigDict, location: FilePath) -&gt; None\n</code></pre> <p>Dump config to TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>toml library is required for writing files</p> Source code in <code>typer_config/dumpers.py</code> <pre><code>def toml_dumper(config: ConfigDict, location: FilePath) -&gt; None:\n\"\"\"Dump config to TOML file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n\n    Raises:\n        ModuleNotFoundError: toml library is required for writing files\n    \"\"\"\n\n    toml = try_import(\"toml\")\n\n    if toml is None:  # pragma: no cover\n        message = \"Please install the toml library to write TOML files.\"\n        raise ModuleNotFoundError(message)\n\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        toml.dump(config, _file)  # type: ignore\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#100-2023-07-19","title":"1.0.0 - 2023-07-19","text":"<p>Compare with 0.6.1</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>removed deprecated code (e363a80 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>ruff linting (#44) (a79245a by Matthew Anderson).</li> </ul>"},{"location":"changelog/#061-2023-07-17","title":"0.6.1 - 2023-07-17","text":"<p>Compare with 0.6.0</p> <ul> <li>update docs to use <code>Annotated</code> parameters (#41) (f2a8a25 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#060-2023-07-17","title":"0.6.0 - 2023-07-17","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>dump configuration on invocation (#27) (b2c7b42 by Matthew Anderson).</li> <li>config decorator (#34) (ae8e44d by Matthew Anderson).</li> </ul>"},{"location":"changelog/#050-2023-05-25","title":"0.5.0 - 2023-05-25","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>loader conditionals (#23) (4bb82de by Matthew Anderson).</li> </ul>"},{"location":"changelog/#040-2023-05-22","title":"0.4.0 - 2023-05-22","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>config loader transformer (#21) (7af9695 by Matthew Anderson). * deps: update to fixed version of griffe</li> </ul>"},{"location":"changelog/#030-2023-05-17","title":"0.3.0 - 2023-05-17","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>INI support (#17) (2ec9aa5 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>reorder release steps (6f83ed0 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#020-2023-05-17","title":"0.2.0 - 2023-05-17","text":"<p>Compare with 0.1.3</p>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>dotenv (#15) (28f5e61 by Matthew Anderson). * feat: dotenv support</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>tooling (ae24220 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#013-2023-05-15","title":"0.1.3 - 2023-05-15","text":"<p>Compare with 0.1.2</p>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>add test for pyproject example (#5) (dbbd1b6 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>change local type module name to match typer (0c087ff by Matthew Anderson).</li> <li>typo (b7a10c3 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#012-2023-05-01","title":"0.1.2 - 2023-05-01","text":"<p>Compare with first commit</p>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>simple example as test (d59962e by Matthew Anderson).</li> <li>initial features (4298289 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>linter (8bfeb82 by Matthew Anderson).</li> <li>tomllib (15f53a5 by Matthew Anderson).</li> <li>typer BadParameter (64868a3 by Matthew Anderson).</li> </ul>"},{"location":"how/","title":"How it works","text":"<p>This library works by mutating the default values in the underlying click context (<code>click.Context.default_map</code>) before the command is executed (see phha/click_config_file). It is essentially overwriting the default values that you specified in your source code. Then, the shell environment variables and CLI parameters are parsed by typer to override the values already set.</p> <p>The <code>@use_config</code> decorator works by modifying your function's signature to include a <code>config</code> parameter with a sane default. The <code>typer</code> library then sees this extended signature and parses/generates the help text for the <code>config</code> parameter. Internally, the decorator then removes the <code>config</code> parameter from the arguments passed to the actual implementation that you wrote. Otherwise, your function would error with an unknown argument.</p> <p>If you use the <code>config</code> parameter directly in your function, you must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first. For example: <pre><code>config: str = typer.Option(\"\", is_eager=True, callback=...)\n</code></pre> If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</p>"},{"location":"install/","title":"Installation","text":"<pre><code>$ pip install typer-config\n</code></pre> <p>Note: this only supports reading json files. See below for more file formats.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>Typer Config provides optional dependency sets to read certain file type:</p> <pre><code>$ pip install typer-config[yaml] # includes pyyaml\n\n$ pip install typer-config[toml] # includes toml\n\n$ pip install typer-config[python-dotenv] # includes python-dotenv\n\n$ pip install typer-config[all] # includes all optional dependencies\n</code></pre>"},{"location":"examples/explicit_config/","title":"Explicit Configuration Parameter","text":"<p>Instead of using the <code>@use_config()</code> decorator, you can explicitly add <code>config</code> to your typer command. However, you must include <code>is_eager=True</code>.</p>"},{"location":"examples/explicit_config/#simple-yaml-example","title":"Simple YAML Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file.</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.callbacks import yaml_conf_callback  # other formats available (1)\n\napp = typer.Typer()\n\n\n@app.command()\ndef main(\n    arg1: str,\n    opt1: Annotated[str, typer.Option()],\n    opt2: Annotated[str, typer.Option()] = \"hello\",\n    config: Annotated[\n        str,\n        typer.Option(\n            callback=yaml_conf_callback,\n            is_eager=True,  # THIS IS REALLY IMPORTANT (2)\n        ),\n    ] = \"\",\n):\n    # possibly do something with config\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li> <p>This package also provides <code>json_conf_callback</code>, <code>toml_conf_callback</code>, and <code>dotenv_conf_callback</code> for those file formats.</p> </li> <li> <p>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</p> </li> </ol> <p>With a config file:</p> config.yml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre>"},{"location":"examples/pydantic/","title":"Pydantic Validation Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file and uses pydantic to validate the file before continuing.</p> <p>An example typer app: simple_app.py<pre><code>from typing import Any, Dict\nfrom typing_extensions import Annotated\n\nfrom pydantic import BaseModel\nimport typer\nfrom typer_config.loaders import yaml_loader\nfrom typer_config.callbacks import conf_callback_factory\nfrom typer_config.decorators import use_config\n\n\nclass AppConfig(BaseModel):\n    arg1: str\n    opt1: str\n    opt2: str\n\n\ndef validator_loader(param_value: str) -&gt; Dict[str, Any]:\n    conf = yaml_loader(param_value)\n    AppConfig.validate(conf)  # raises an exception if not valid\n    return conf\n\n\nvalidator_callback = conf_callback_factory(validator_loader)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_config(validator_callback)\ndef main(\n    arg1: str,\n    opt1: Annotated[str, typer.Option()],\n    opt2: Annotated[str, typer.Option()] = \"hello\",\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <p>With a config file:</p> config.yml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> <pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre>"},{"location":"examples/pyproject/","title":"Pyproject TOML loader","text":"<p>If you use an unsupported file format or need to do extra processing of the file, you can make your own file loader and construct an appropriate callback.</p> <p>Suppose you want to specify parameters in a section of <code>pyproject.toml</code>:</p> pyproject.toml<pre><code>[tool.my_tool.parameters]\narg1 = \"stuff\"\nopt1 = \"things\"\nopt2 = \"nothing\"\n</code></pre> <p>Then, we can read the values in our typer CLI:</p> my_tool.py<pre><code>from typing import Any, Dict\nfrom typing_extensions import Annotated\n\nimport typer\nfrom typer_config import conf_callback_factory\nfrom typer_config.loaders import toml_loader\nfrom typer_config.decorators import use_config\n\n\ndef pyproject_loader(param_value: str) -&gt; Dict[str, Any]:\n    if not param_value:  # set a default path to read from\n        param_value = \"pyproject.toml\"\n    pyproject = toml_loader(param_value)\n    conf = pyproject[\"tool\"][\"my_tool\"][\"parameters\"]\n    return conf\n\n\n### You can define the same loader using the loader_transformer combinator:\n#\n# from typer_config.loaders import loader_transformer\n\n# pyproject_loader = loader_transformer(\n#     toml_loader,\n#     param_transformer=lambda param: param or \"pyproject.toml\",\n#     config_transformer=lambda config: config[\"tool\"][\"my_tool\"][\"parameters\"],\n# )\n\npyproject_callback = conf_callback_factory(pyproject_loader)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_config(pyproject_callback)\ndef main(\n    arg1: str,\n    opt1: Annotated[str, typer.Option()],\n    opt2: Annotated[str, typer.Option()] = \"hello\",\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <p>And we get this behavior:</p> <pre><code>$ ls .\nmy_tool.py\nother.toml\npyproject.toml\n\n$ python my_tool.py\nthings nothing stuff\n\n$ python my_tool.py others\nthings nothing others\n\n$ python my_tool.py --config other.toml\nsomething else entirely\n</code></pre>"},{"location":"examples/save_config/","title":"Save Config Files","text":"<p>This example shows you how save the parameters of the invoked command to a configuration file using the <code>@dump_config</code> decorator which operates on Typer commands (requested in issue #25).</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import (\n    dump_json_config,  # other formats available (1)\n    use_json_config,\n)\n\n\napp = typer.Typer()\n\n\n@app.command()\n@use_json_config()  # before dump decorator (2)\n@dump_json_config(\"./dumped.json\")\ndef main(\n    arg1: str,\n    opt1: Annotated[str, typer.Option()],\n    opt2: Annotated[str, typer.Option()] = \"hello\",\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li> <p>This package also provides <code>@dump_yaml_config</code> and <code>@dump_toml_config</code> for those file formats.</p> </li> <li> <p>If you put <code>@use_json_config</code> before <code>@dump_json_config</code>, you will not capture the <code>config</code> parameter in your config dump. You probably want this behavior to avoid cascading config files.</p> </li> </ol> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --opt1 foo --opt2 bar baz\nfoo bar baz\n\n$ cat ./dumped.json\n{\"arg1\": \"baz\", \"opt1\": \"foo\", \"opt2\": \"bar\"}\n</code></pre>"},{"location":"examples/schema/","title":"Schema Validation Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file and uses schema to validate the file before continuing.</p> <p>An example typer app: simple_app.py<pre><code>from typing import Any, Dict\nfrom typing_extensions import Annotated\n\nfrom schema import Schema\nimport typer\nfrom typer_config import yaml_loader, conf_callback_factory, use_config\n\nschema = Schema({\"arg1\": str, \"opt1\": str, \"opt2\": str})\n\n\ndef validator_loader(param_value: str) -&gt; Dict[str, Any]:\n    conf = yaml_loader(param_value)\n    conf = schema.validate(conf)  # raises an exception if not valid\n    return conf\n\n\nvalidator_callback = conf_callback_factory(validator_loader)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_config(validator_callback)\ndef main(\n    arg1: str,\n    opt1: Annotated[str, typer.Option()],\n    opt2: Annotated[str, typer.Option()] = \"hello\",\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</li> </ol> <p>With a config file:</p> config.yml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> <pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre>"},{"location":"examples/simple_yaml/","title":"Simple YAML Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file.</p> <p>An example typer app: simple_app.py<pre><code>from typing_extensions import Annotated\n\nimport typer\nfrom typer_config.decorators import use_yaml_config  # other formats available (1)\n\napp = typer.Typer()\n\n\n@app.command()\n@use_yaml_config()\ndef main(\n    arg1: str,\n    opt1: Annotated[str, typer.Option()],\n    opt2: Annotated[str, typer.Option()] = \"hello\",\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li> <p>This package also provides <code>use_json_config</code>, <code>use_toml_config</code>, and <code>use_dotenv_config</code> for those file formats.</p> </li> <li> <p>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</p> </li> </ol> <p>With a config file:</p> config.yml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre>"}]}