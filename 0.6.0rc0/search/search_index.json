{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"typer-config","text":"<p>This is a collection of utilities to use configuration files to set parameters for a typer CLI. It is useful for typer commands with many options/arguments so you don't have to constantly rewrite long commands. This package was inspired by phha/click_config_file and prototyped in this issue. It allows you to set values for CLI parameters using a configuration file. </p> <pre><code># Long commands like this:\n$ my-typer-app --opt1 foo --opt2 bar arg1 arg2\n\n# Can become this:\n$ my-typer-app --config config.yml\n</code></pre> <p>See Examples for more.</p>"},{"location":"api/","title":"typer_config","text":"<p>Typer Configuration Utilities</p>"},{"location":"api/#typer_config.__typing","title":"__typing","text":"<p>Data and Function types.</p>"},{"location":"api/#typer_config.__typing.TyperParameterName","title":"TyperParameterName  <code>module-attribute</code>","text":"<pre><code>TyperParameterName: TypeAlias = str\n</code></pre> <p>Typer CLI parameter name.</p>"},{"location":"api/#typer_config.__typing.TyperParameterValue","title":"TyperParameterValue  <code>module-attribute</code>","text":"<pre><code>TyperParameterValue: TypeAlias = Any\n</code></pre> <p>Typer CLI parameter value.</p>"},{"location":"api/#typer_config.__typing.ConfigDict","title":"ConfigDict  <code>module-attribute</code>","text":"<pre><code>ConfigDict: TypeAlias = Dict[TyperParameterName, Any]\n</code></pre> <p>Configuration dictionary to be applied to the click context default map.</p>"},{"location":"api/#typer_config.__typing.ConfigDictAccessorPath","title":"ConfigDictAccessorPath  <code>module-attribute</code>","text":"<pre><code>ConfigDictAccessorPath: TypeAlias = Iterable[str]\n</code></pre> <p>Configuration dictionary accessor path.</p>"},{"location":"api/#typer_config.__typing.FilePath","title":"FilePath  <code>module-attribute</code>","text":"<pre><code>FilePath: TypeAlias = Union[Path, str]\n</code></pre> <p>File path</p>"},{"location":"api/#typer_config.__typing.TyperParameterValueTransformer","title":"TyperParameterValueTransformer  <code>module-attribute</code>","text":"<pre><code>TyperParameterValueTransformer: TypeAlias = Callable[\n    [TyperParameterValue], TyperParameterValue\n]\n</code></pre> <p>Typer parameter value transforming function.</p>"},{"location":"api/#typer_config.__typing.ConfigDictTransformer","title":"ConfigDictTransformer  <code>module-attribute</code>","text":"<pre><code>ConfigDictTransformer: TypeAlias = Callable[\n    [ConfigDict], ConfigDict\n]\n</code></pre> <p>ConfigDict transforming function.</p>"},{"location":"api/#typer_config.__typing.ConfigLoader","title":"ConfigLoader  <code>module-attribute</code>","text":"<pre><code>ConfigLoader: TypeAlias = Callable[\n    [TyperParameterValue], ConfigDict\n]\n</code></pre> <p>Configuration loader function.</p>"},{"location":"api/#typer_config.__typing.ConfigLoaderConditional","title":"ConfigLoaderConditional  <code>module-attribute</code>","text":"<pre><code>ConfigLoaderConditional: TypeAlias = Callable[\n    [TyperParameterValue], bool\n]\n</code></pre> <p>Configuration loader conditional function.</p>"},{"location":"api/#typer_config.__typing.ConfigParameterCallback","title":"ConfigParameterCallback  <code>module-attribute</code>","text":"<pre><code>ConfigParameterCallback: TypeAlias = Callable[\n    [Context, CallbackParam, TyperParameterValue],\n    TyperParameterValue,\n]\n</code></pre> <p>Typer config parameter callback function.</p>"},{"location":"api/#typer_config.__typing.NoArgCallable","title":"NoArgCallable  <code>module-attribute</code>","text":"<pre><code>NoArgCallable: TypeAlias = Callable[[], Any]\n</code></pre> <p>No argument callable.</p>"},{"location":"api/#typer_config.__typing.ConfigDumper","title":"ConfigDumper  <code>module-attribute</code>","text":"<pre><code>ConfigDumper: TypeAlias = Callable[\n    [ConfigDict, FilePath], None\n]\n</code></pre> <p>Configuration dumper function.</p>"},{"location":"api/#typer_config.__typing.TyperCommand","title":"TyperCommand  <code>module-attribute</code>","text":"<pre><code>TyperCommand: TypeAlias = Callable[..., Any]\n</code></pre> <p>A function that will be decorated with <code>typer.Typer().command()</code>.</p>"},{"location":"api/#typer_config.__typing.TyperCommandDecorator","title":"TyperCommandDecorator  <code>module-attribute</code>","text":"<pre><code>TyperCommandDecorator: TypeAlias = Callable[\n    [TyperCommand], TyperCommand\n]\n</code></pre> <p>A decorator applied to a typer command.</p>"},{"location":"api/#typer_config.loaders","title":"loaders","text":"<p>Configuration File Loaders.</p> <p>These loaders must implement the <code>typer_config.__typing.ConfigLoader</code> interface.</p>"},{"location":"api/#typer_config.loaders.loader_transformer","title":"loader_transformer","text":"<pre><code>loader_transformer(\n    loader: ConfigLoader,\n    loader_conditional: Optional[\n        ConfigLoaderConditional\n    ] = None,\n    param_transformer: Optional[\n        TyperParameterValueTransformer\n    ] = None,\n    config_transformer: Optional[\n        ConfigDictTransformer\n    ] = None,\n) -&gt; ConfigLoader\n</code></pre> <p>Configuration loader transformer.</p> <p>This allows to transform the input and output of a configuration loader.</p> <p>Examples:</p> <p>Set a default file to open when none is given: <pre><code>default_file_loader = loader_transformer(\n    yaml_loader,\n    param_transformer=lambda param: param if param else \"config.yml\",\n)\n</code></pre></p> <p>Use a subsection of a file: <pre><code>subsection_loader = loader_transformer(\n    yaml_loader,\n    config_transformer = lambda config: config[\"subsection\"],\n)\n</code></pre></p> <p>Use both transformers to use the <code>[tool.my_tool]</code> section from <code>pyproject.toml</code> by default: <pre><code>pyproject_loader = loader_transformer(\n    toml_loader,\n    param_transformer = lambda param: param if param else \"pyproject.toml\"\n    config_transformer = lambda config: config[\"tool\"][\"my_tool\"],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Loader to transform.</p> required <code>loader_conditional</code> <code>Optional[ConfigLoaderConditional]</code> <p>Function to determine whether to execute loader. Defaults to None (no-op).</p> <code>None</code> <code>param_transformer</code> <code>Optional[TyperParameterValueTransformer]</code> <p>Typer parameter transformer. Defaults to None (no-op).</p> <code>None</code> <code>config_transformer</code> <code>Optional[ConfigDictTransformer]</code> <p>Config dictionary transformer. Defaults to None (no-op).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ConfigLoader</code> <code>ConfigLoader</code> <p>Transformed config loader.</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def loader_transformer(\n    loader: ConfigLoader,\n    loader_conditional: Optional[ConfigLoaderConditional] = None,\n    param_transformer: Optional[TyperParameterValueTransformer] = None,\n    config_transformer: Optional[ConfigDictTransformer] = None,\n) -&gt; ConfigLoader:\n\"\"\"Configuration loader transformer.\n\n    This allows to transform the input and output of a configuration loader.\n\n    Examples:\n        Set a default file to open when none is given:\n        ```py\n        default_file_loader = loader_transformer(\n            yaml_loader,\n            param_transformer=lambda param: param if param else \"config.yml\",\n        )\n        ```\n\n        Use a subsection of a file:\n        ```py\n        subsection_loader = loader_transformer(\n            yaml_loader,\n            config_transformer = lambda config: config[\"subsection\"],\n        )\n        ```\n\n        Use both transformers to use the `[tool.my_tool]` section from `pyproject.toml`\n        by default:\n        ```py\n        pyproject_loader = loader_transformer(\n            toml_loader,\n            param_transformer = lambda param: param if param else \"pyproject.toml\"\n            config_transformer = lambda config: config[\"tool\"][\"my_tool\"],\n        )\n        ```\n\n    Args:\n        loader (ConfigLoader): Loader to transform.\n        loader_conditional (Optional[ConfigLoaderConditional], optional): Function\n            to determine whether to execute loader. Defaults to None (no-op).\n        param_transformer (Optional[TyperParameterValueTransformer], optional): Typer\n            parameter transformer. Defaults to None (no-op).\n        config_transformer (Optional[ConfigDictTransformer], optional): Config\n            dictionary transformer. Defaults to None (no-op).\n\n    Returns:\n        ConfigLoader: Transformed config loader.\n    \"\"\"\n\n    def _loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n        # Transform input\n        if param_transformer is not None:\n            param_value = param_transformer(param_value)\n\n        # Decide whether to execute loader\n        # NOTE: bad things can happen when `param_value=''`\n        # such as `--help` not working\n        conf: ConfigDict = {}\n        if loader_conditional is None or loader_conditional(param_value):\n            conf = loader(param_value)\n\n        # Transform output\n        if config_transformer is not None:\n            conf = config_transformer(conf)\n\n        return conf\n\n    return _loader\n</code></pre>"},{"location":"api/#typer_config.loaders.subpath_loader","title":"subpath_loader","text":"<pre><code>subpath_loader(\n    loader: ConfigLoader, dictpath: ConfigDictAccessorPath\n) -&gt; ConfigLoader\n</code></pre> <p>Modify a loader to return a subpath of the dictionary from file.</p> <p>Warns:</p> Type Description <code>DeprecationWarning</code> <p>This function is deprecated. Please use typer_config.loaders.loader_transformer instead.</p> <p>Examples:</p> <p>The following example reads the values from the <code>my_app</code> section in a YAML file structured like this: <pre><code>tools:\nmy_app:\n... # use these values\nothers: # ignore\nstuff: # ignore\n</code></pre></p> <pre><code>my_loader = subpath_loader(yaml_loader, [\"tools\", \"my_app\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>loader to modify</p> required <code>dictpath</code> <code>ConfigDictAccessorPath</code> <p>path to the section of dictionary</p> required <p>Returns:</p> Name Type Description <code>ConfigLoader</code> <code>ConfigLoader</code> <p>sub dictionary loader</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def subpath_loader(\n    loader: ConfigLoader, dictpath: ConfigDictAccessorPath\n) -&gt; ConfigLoader:\n\"\"\"Modify a loader to return a subpath of the dictionary from file.\n\n    Warns:\n        DeprecationWarning: This function is deprecated. Please use\n            typer_config.loaders.loader_transformer instead.\n\n    Examples:\n        The following example reads the values from the `my_app` section in\n        a YAML file structured like this:\n        ```yaml\n        tools:\n            my_app:\n                ... # use these values\n            others: # ignore\n        stuff: # ignore\n        ```\n\n        ```py\n        my_loader = subpath_loader(yaml_loader, [\"tools\", \"my_app\"])\n        ```\n\n    Args:\n        loader (ConfigLoader): loader to modify\n        dictpath (ConfigDictAccessorPath): path to the section of dictionary\n\n    Returns:\n        ConfigLoader: sub dictionary loader\n    \"\"\"\n\n    warn(\n        \"typer_config.loaders.subpath_loader is deprecated. \"\n        \"Please use typer_config.loaders.loader_transformer instead.\",\n        DeprecationWarning,\n    )\n\n    def _loader(param_value: str) -&gt; ConfigDict:\n        # get original ConfigDict\n        conf: ConfigDict = loader(param_value)\n\n        # get subpath of dictionary\n        for path in dictpath:\n            conf = conf.get(path, {})\n        return conf\n\n    return _loader\n</code></pre>"},{"location":"api/#typer_config.loaders.default_value_loader","title":"default_value_loader","text":"<pre><code>default_value_loader(\n    loader: ConfigLoader, value_getter: NoArgCallable\n) -&gt; ConfigLoader\n</code></pre> <p>Modify a loader to use a default value if the passed value is false-ish.</p> <p>Warns:</p> Type Description <code>DeprecationWarning</code> <p>This function is deprecated. Please use typer_config.loaders.loader_transformer instead.</p> <p>Examples:</p> <p>The following example lets a user specify a config file, but will load the <code>pyproject.toml</code> if they don't.</p> <pre><code>pyproject_loader = default_value_loader(toml_loader, lambda: \"pyproject.toml\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>loader to modify</p> required <code>value_getter</code> <code>NoArgCallable</code> <p>function that returns default value</p> required <p>Returns:</p> Name Type Description <code>ConfigLoader</code> <code>ConfigLoader</code> <p>modified loader</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def default_value_loader(\n    loader: ConfigLoader, value_getter: NoArgCallable\n) -&gt; ConfigLoader:\n\"\"\"Modify a loader to use a default value if the passed value is false-ish.\n\n    Warns:\n        DeprecationWarning: This function is deprecated. Please use\n            typer_config.loaders.loader_transformer instead.\n\n    Examples:\n        The following example lets a user specify a config file, but will load\n        the `pyproject.toml` if they don't.\n\n        ```py\n        pyproject_loader = default_value_loader(toml_loader, lambda: \"pyproject.toml\")\n        ```\n\n    Args:\n        loader (ConfigLoader): loader to modify\n        value_getter (NoArgCallable): function that returns default value\n\n\n\n    Returns:\n        ConfigLoader: modified loader\n    \"\"\"\n\n    warn(\n        \"typer_config.loaders.default_value_loader is deprecated. \"\n        \"Please use typer_config.loaders.loader_transformer instead.\",\n        DeprecationWarning,\n    )\n\n    def _loader(param_value: str) -&gt; ConfigDict:\n        # parameter value was not specified by user\n        if not param_value:\n            param_value = value_getter()\n\n        conf: ConfigDict = loader(param_value)\n\n        return conf\n\n    return _loader\n</code></pre>"},{"location":"api/#typer_config.loaders.yaml_loader","title":"yaml_loader","text":"<pre><code>yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>YAML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of YAML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>pyyaml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def yaml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"YAML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of YAML file\n\n    Raises:\n        ModuleNotFoundError: pyyaml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    if YAML_MISSING:  # pragma: no cover\n        raise ModuleNotFoundError(\"Please install the pyyaml library.\")\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = yaml.safe_load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.json_loader","title":"json_loader","text":"<pre><code>json_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>JSON file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of JSON file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def json_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"JSON file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of JSON file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        conf: ConfigDict = json.load(_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.toml_loader","title":"toml_loader","text":"<pre><code>toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>TOML file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of TOML file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>toml library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def toml_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"TOML file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of TOML file\n\n    Raises:\n        ModuleNotFoundError: toml library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    if USING_TOMLLIB:  # pragma: no cover\n        with open(param_value, \"rb\") as _file:\n            return tomllib.load(_file)  # type: ignore\n\n    if TOML_MISSING:  # pragma: no cover\n        raise ModuleNotFoundError(\"Please install the toml library.\")\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:  # pragma: no cover\n        return toml.load(_file)  # type: ignore\n</code></pre>"},{"location":"api/#typer_config.loaders.dotenv_loader","title":"dotenv_loader","text":"<pre><code>dotenv_loader(\n    param_value: TyperParameterValue,\n) -&gt; ConfigDict\n</code></pre> <p>Dotenv file loader.</p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of Dotenv file</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>python-dotenv library is not installed</p> <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def dotenv_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"Dotenv file loader.\n\n    Args:\n        param_value (TyperParameterValue): path of Dotenv file\n\n    Raises:\n        ModuleNotFoundError: python-dotenv library is not installed\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    if DOTENV_MISSING:  # pragma: no cover\n        raise ModuleNotFoundError(\"Please install the python-dotenv library.\")\n\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        # NOTE: I'm using a stream here so that the loader\n        # will raise an exception when the file doesn't exist.\n        conf: ConfigDict = dotenv.dotenv_values(stream=_file)\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.loaders.ini_loader","title":"ini_loader","text":"<pre><code>ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict\n</code></pre> <p>INI file loader</p> Note <p>INI files must have sections at the top level. You probably want to combine this with <code>subpath_loader</code>. For example: <pre><code>ini_section_loader = subpath_loader(ini_loader, [\"section\"])\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>param_value</code> <code>TyperParameterValue</code> <p>path of INI file</p> required <p>Returns:</p> Name Type Description <code>ConfigDict</code> <code>ConfigDict</code> <p>dictionary loaded from file</p> Source code in <code>typer_config/loaders.py</code> <pre><code>def ini_loader(param_value: TyperParameterValue) -&gt; ConfigDict:\n\"\"\"INI file loader\n\n    Note:\n        INI files must have sections at the top level.\n        You probably want to combine this with `subpath_loader`.\n        For example:\n        ```py\n        ini_section_loader = subpath_loader(ini_loader, [\"section\"])\n        ```\n\n    Args:\n        param_value (TyperParameterValue): path of INI file\n\n    Returns:\n        ConfigDict: dictionary loaded from file\n    \"\"\"\n\n    ini_parser = ConfigParser()\n    with open(param_value, \"r\", encoding=\"utf-8\") as _file:\n        ini_parser.read_file(_file)\n\n    conf: ConfigDict = {\n        sect: dict(ini_parser.items(sect)) for sect in ini_parser.sections()\n    }\n\n    return conf\n</code></pre>"},{"location":"api/#typer_config.callbacks","title":"callbacks","text":"<p>Typer Configuration Parameter Callbacks.</p>"},{"location":"api/#typer_config.callbacks.yaml_conf_callback","title":"yaml_conf_callback  <code>module-attribute</code>","text":"<pre><code>yaml_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        yaml_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>YAML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.json_conf_callback","title":"json_conf_callback  <code>module-attribute</code>","text":"<pre><code>json_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        json_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>JSON typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.toml_conf_callback","title":"toml_conf_callback  <code>module-attribute</code>","text":"<pre><code>toml_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        toml_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>TOML typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.dotenv_conf_callback","title":"dotenv_conf_callback  <code>module-attribute</code>","text":"<pre><code>dotenv_conf_callback: ConfigParameterCallback = conf_callback_factory(\n    loader_transformer(\n        dotenv_loader,\n        loader_conditional=lambda param_value: param_value,\n    )\n)\n</code></pre> <p>Dotenv typer config parameter callback.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>typer context (automatically passed)</p> required <code>param</code> <code>typer.CallbackParam</code> <p>typer callback parameter (automatically passed)</p> required <code>param_value</code> <code>TyperParameterValue</code> <p>parameter value passed to typer (automatically passed)</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>bad parameter value</p> <p>Returns:</p> Name Type Description <code>TyperParameterValue</code> <code>ConfigParameterCallback</code> <p>must return back the given parameter</p>"},{"location":"api/#typer_config.callbacks.conf_callback_factory","title":"conf_callback_factory","text":"<pre><code>conf_callback_factory(\n    loader: ConfigLoader,\n) -&gt; ConfigParameterCallback\n</code></pre> <p>Typer configuration callback factory.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>ConfigLoader</code> <p>Config loader function that takes the value passed to the typer CLI and returns a dictionary that is applied to the click context's default map.</p> required <p>Returns:</p> Name Type Description <code>ConfigParameterCallback</code> <code>ConfigParameterCallback</code> <p>Configuration parameter callback function.</p> Source code in <code>typer_config/callbacks.py</code> <pre><code>def conf_callback_factory(loader: ConfigLoader) -&gt; ConfigParameterCallback:\n\"\"\"Typer configuration callback factory.\n\n    Args:\n        loader (ConfigLoader): Config loader function that takes the value\n            passed to the typer CLI and returns a dictionary that is\n            applied to the click context's default map.\n\n    Returns:\n        ConfigParameterCallback: Configuration parameter callback function.\n    \"\"\"\n\n    def _callback(\n        ctx: Context, param: CallbackParam, param_value: TyperParameterValue\n    ) -&gt; TyperParameterValue:\n\"\"\"Generated typer config parameter callback.\n\n        Args:\n            ctx (typer.Context): typer context (automatically passed)\n            param (typer.CallbackParam): typer callback parameter (automatically passed)\n            param_value (TyperParameterValue): parameter value passed to typer\n                (automatically passed)\n\n        Raises:\n            BadParameter: bad parameter value\n\n        Returns:\n            TyperParameterValue: must return back the given parameter\n        \"\"\"\n        try:\n            conf = loader(param_value)  # Load config file\n            ctx.default_map = ctx.default_map or {}  # Initialize the default map\n            ctx.default_map.update(conf)  # Merge the config Dict into default_map\n        except Exception as ex:\n            raise BadParameter(str(ex), ctx=ctx, param=param) from ex\n        return param_value\n\n    return _callback\n</code></pre>"},{"location":"api/#typer_config.__optional_imports","title":"__optional_imports","text":"<p>Handle optional and version dependent imports.</p> <p>Note: Be careful with this file because other files wildcard import from here.</p>"},{"location":"api/#typer_config.dumpers","title":"dumpers","text":"<p>Config Dictionary Dumpers.</p>"},{"location":"api/#typer_config.dumpers.json_dumper","title":"json_dumper","text":"<pre><code>json_dumper(config: ConfigDict, location: FilePath)\n</code></pre> <p>Dump config to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required Source code in <code>typer_config/dumpers.py</code> <pre><code>def json_dumper(config: ConfigDict, location: FilePath):\n\"\"\"Dump config to JSON file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n    \"\"\"\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        json.dump(config, _file)\n</code></pre>"},{"location":"api/#typer_config.dumpers.yaml_dumper","title":"yaml_dumper","text":"<pre><code>yaml_dumper(config: ConfigDict, location: FilePath)\n</code></pre> <p>Dump config to YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>pyyaml is required</p> Source code in <code>typer_config/dumpers.py</code> <pre><code>def yaml_dumper(config: ConfigDict, location: FilePath):\n\"\"\"Dump config to YAML file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n\n    Raises:\n        ModuleNotFoundError: pyyaml is required\n    \"\"\"\n\n    if YAML_MISSING:  # pragma: no cover\n        raise ModuleNotFoundError(\"Please install the pyyaml library.\")\n\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        # NOTE: we must convert config from OrderedDict to dict because\n        # pyyaml can't load OrderedDict for python &lt;= 3.8\n        yaml.dump(dict(config), _file)\n</code></pre>"},{"location":"api/#typer_config.dumpers.toml_dumper","title":"toml_dumper","text":"<pre><code>toml_dumper(config: ConfigDict, location: FilePath)\n</code></pre> <p>Dump config to TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>configuration</p> required <code>location</code> <code>FilePath</code> <p>file to write</p> required <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>toml library is required for writing files</p> Source code in <code>typer_config/dumpers.py</code> <pre><code>def toml_dumper(config: ConfigDict, location: FilePath):\n\"\"\"Dump config to TOML file.\n\n    Args:\n        config (ConfigDict): configuration\n        location (FilePath): file to write\n\n    Raises:\n        ModuleNotFoundError: toml library is required for writing files\n    \"\"\"\n\n    if TOML_MISSING:  # pragma: no cover\n        raise ModuleNotFoundError(\n            \"Please install the toml library to write TOML files.\"\n        )\n\n    with open(location, \"w\", encoding=\"utf-8\") as _file:\n        toml.dump(config, _file)  # type: ignore\n</code></pre>"},{"location":"api/#typer_config.decorators","title":"decorators","text":"<p>Typer Config decorators.</p>"},{"location":"api/#typer_config.decorators.use_config","title":"use_config","text":"<pre><code>use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_config\nfrom typer_config import yaml_conf_callback # whichever callback to use\n\napp = typer.Typer()\n\n@app.command()\n@use_config(yaml_conf_callback)\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>ConfigParameterCallback</code> <p>config parameter callback to load</p> required <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_config(\n    callback: ConfigParameterCallback,\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_config\n        from typer_config import yaml_conf_callback # whichever callback to use\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_config(yaml_conf_callback)\n        def main(...):\n            ...\n        ```\n\n    Args:\n        callback (ConfigParameterCallback): config parameter callback to load\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n\n    def decorator(cmd: TyperCommand) -&gt; TyperCommand:\n        # NOTE: modifying a function's __signature__ is dangerous\n        # in the sense that it only affects inspect.signature().\n        # It does not affect the actual function implementation.\n        # So, a caller can be confused how to pass parameters to\n        # the function with modified signature.\n        sig = signature(cmd)\n\n        config_param = Parameter(\n            param_name,\n            kind=Parameter.KEYWORD_ONLY,\n            annotation=str,\n            default=Option(\"\", callback=callback, is_eager=True, help=param_help),\n        )\n\n        new_sig = sig.replace(parameters=[*sig.parameters.values(), config_param])\n\n        @wraps(cmd)\n        def wrapped(*args, **kwargs):\n            # NOTE: need to delete the config parameter\n            # to match the wrapped command's signature.\n            if param_name in kwargs:\n                del kwargs[param_name]\n\n            return cmd(*args, **kwargs)\n\n        wrapped.__signature__ = new_sig  # type: ignore\n\n        return wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/#typer_config.decorators.use_json_config","title":"use_json_config","text":"<pre><code>use_json_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using JSON configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_json_config\n\napp = typer.Typer()\n\n@app.command()\n@use_json_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>TyperParameterName</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_json_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using JSON configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_json_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_json_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (TyperParameterName, optional): name of config parameter.\n            Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=json_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.decorators.use_yaml_config","title":"use_yaml_config","text":"<pre><code>use_yaml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using YAML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_yaml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_yaml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_yaml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using YAML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_yaml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_yaml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=yaml_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.decorators.use_toml_config","title":"use_toml_config","text":"<pre><code>use_toml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using TOML configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_toml_config\n\napp = typer.Typer()\n\n@app.command()\n@use_toml_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_toml_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using TOML configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_toml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_toml_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=toml_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.decorators.use_dotenv_config","title":"use_dotenv_config","text":"<pre><code>use_dotenv_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for using dotenv configuration on a typer command.</p> Usage <pre><code>import typer\nfrom typer_config.decorators import use_dotenv_config\n\napp = typer.Typer()\n\n@app.command()\n@use_dotenv_config()\ndef main(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>name of config parameter. Defaults to \"config\".</p> <code>'config'</code> <code>param_help</code> <code>str</code> <p>config parameter help string. Defaults to \"Configuration file.\".</p> <code>'Configuration file.'</code> <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>decorator to apply to command</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def use_dotenv_config(\n    param_name: TyperParameterName = \"config\",\n    param_help: str = \"Configuration file.\",\n) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for using dotenv configuration on a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer_config.decorators import use_dotenv_config\n\n        app = typer.Typer()\n\n        @app.command()\n        @use_dotenv_config()\n        def main(...):\n            ...\n        ```\n\n    Args:\n        param_name (str, optional): name of config parameter. Defaults to \"config\".\n        param_help (str, optional): config parameter help string.\n            Defaults to \"Configuration file.\".\n\n    Returns:\n        TyperCommandDecorator: decorator to apply to command\n    \"\"\"\n    return use_config(\n        callback=dotenv_conf_callback, param_name=param_name, param_help=param_help\n    )\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_config","title":"dump_config","text":"<pre><code>dump_config(\n    dumper: ConfigDumper, location: FilePath\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a config file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_config MUST BE AFTER @app.command()\n@dump_config(yaml_dumper, \"config_dump_dir/params.yaml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>ConfigDumper</code> <p>config file dumper</p> required <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def dump_config(dumper: ConfigDumper, location: FilePath) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for dumping a config file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_config MUST BE AFTER @app.command()\n        @dump_config(yaml_dumper, \"config_dump_dir/params.yaml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        dumper (ConfigDumper): config file dumper\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n\n    def decorator(cmd: TyperCommand) -&gt; TyperCommand:\n        @wraps(cmd)\n        def inner(*args, **kwargs):\n            # get a dictionary of the passed args\n            bound_args = signature(cmd).bind(*args, **kwargs).arguments\n\n            # convert enums to their values\n            # NOTE: bound_args shouldn't be nested in the typer\n            # framework, so top level iteration should be fine.\n            for key, val in bound_args.items():\n                if isinstance(val, Enum):\n                    bound_args[key] = val.value\n\n            # dump passed args\n            dumper(bound_args, location)\n\n            # run original command\n            return cmd(*args, **kwargs)\n\n        return inner\n\n    return decorator\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_json_config","title":"dump_json_config","text":"<pre><code>dump_json_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a JSON file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_json_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_json_config MUST BE AFTER @app.command()\n@dump_json_config(\"config_dump_dir/params.json\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def dump_json_config(location: FilePath) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for dumping a JSON file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_json_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_json_config MUST BE AFTER @app.command()\n        @dump_json_config(\"config_dump_dir/params.json\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=json_dumper, location=location)\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_yaml_config","title":"dump_yaml_config","text":"<pre><code>dump_yaml_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a YAML file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_yaml_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_yaml_config MUST BE AFTER @app.command()\n@dump_yaml_config(\"config_dump_dir/params.yml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def dump_yaml_config(location: FilePath) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for dumping a YAML file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_yaml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_yaml_config MUST BE AFTER @app.command()\n        @dump_yaml_config(\"config_dump_dir/params.yml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=yaml_dumper, location=location)\n</code></pre>"},{"location":"api/#typer_config.decorators.dump_toml_config","title":"dump_toml_config","text":"<pre><code>dump_toml_config(\n    location: FilePath,\n) -&gt; TyperCommandDecorator\n</code></pre> <p>Decorator for dumping a TOML file with parameters from an invocation of a typer command.</p> Usage <pre><code>import typer\nfrom typer.decorators import dump_toml_config\n\napp = typer.Typer()\n\n@app.command()\n# NOTE: @dump_toml_config MUST BE AFTER @app.command()\n@dump_toml_config(\"config_dump_dir/params.toml\")\ndef cmd(...):\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FilePath</code> <p>config file to write</p> required <p>Returns:</p> Name Type Description <code>TyperCommandDecorator</code> <code>TyperCommandDecorator</code> <p>command decorator</p> Source code in <code>typer_config/decorators.py</code> <pre><code>def dump_toml_config(location: FilePath) -&gt; TyperCommandDecorator:\n\"\"\"Decorator for dumping a TOML file with parameters\n    from an invocation of a typer command.\n\n    Usage:\n        ```py\n        import typer\n        from typer.decorators import dump_toml_config\n\n        app = typer.Typer()\n\n        @app.command()\n        # NOTE: @dump_toml_config MUST BE AFTER @app.command()\n        @dump_toml_config(\"config_dump_dir/params.toml\")\n        def cmd(...):\n            ...\n        ```\n\n    Args:\n        location (FilePath): config file to write\n\n    Returns:\n        TyperCommandDecorator: command decorator\n    \"\"\"\n    return dump_config(dumper=toml_dumper, location=location)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#060rc0-2023-07-17","title":"0.6.0rc0 - 2023-07-17","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>dump configuration on invocation (#27) (b2c7b42 by Matthew Anderson).</li> <li>config decorator (#34) (ae8e44d by Matthew Anderson).</li> </ul>"},{"location":"changelog/#050-2023-05-25","title":"0.5.0 - 2023-05-25","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>loader conditionals (#23) (4bb82de by Matthew Anderson).</li> </ul>"},{"location":"changelog/#040-2023-05-22","title":"0.4.0 - 2023-05-22","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>config loader transformer (#21) (7af9695 by Matthew Anderson). * deps: update to fixed version of griffe</li> </ul>"},{"location":"changelog/#030-2023-05-17","title":"0.3.0 - 2023-05-17","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>INI support (#17) (2ec9aa5 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>reorder release steps (6f83ed0 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#020-2023-05-17","title":"0.2.0 - 2023-05-17","text":"<p>Compare with 0.1.3</p>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>dotenv (#15) (28f5e61 by Matthew Anderson). * feat: dotenv support</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>tooling (ae24220 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#013-2023-05-15","title":"0.1.3 - 2023-05-15","text":"<p>Compare with 0.1.2</p>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>add test for pyproject example (#5) (dbbd1b6 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>change local type module name to match typer (0c087ff by Matthew Anderson).</li> <li>typo (b7a10c3 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#012-2023-05-01","title":"0.1.2 - 2023-05-01","text":"<p>Compare with first commit</p>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>simple example as test (d59962e by Matthew Anderson).</li> <li>initial features (4298289 by Matthew Anderson).</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>linter (8bfeb82 by Matthew Anderson).</li> <li>tomllib (15f53a5 by Matthew Anderson).</li> <li>typer BadParameter (64868a3 by Matthew Anderson).</li> </ul>"},{"location":"how/","title":"How it works","text":"<p>This works by mutating the default values in the underlying click context (<code>click.Context.default_map</code>) before the command is executed (see phha/click_config_file). It is essentially overwriting the default values that you specified in your source code. Then, the shell environment variables and CLI parameters are parsed by typer to override the values already set.</p> <p>Note: You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.   If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</p>"},{"location":"install/","title":"Installation","text":"<pre><code>$ pip install typer-config\n</code></pre> <p>Note: this only supports reading json files. See below for more file formats.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>Typer Config provides optional dependency sets to read certain file type:</p> <pre><code>$ pip install typer-config[yaml] # includes pyyaml\n\n$ pip install typer-config[toml] # includes toml\n\n$ pip install typer-config[python-dotenv] # includes python-dotenv\n\n$ pip install typer-config[all] # includes all optional dependencies\n</code></pre>"},{"location":"examples/decorator/","title":"Decorator Syntax","text":"<p>New in 0.6.0</p> <p>You can use a decorator to indicate that your <code>typer</code> command uses a config option. This is meant to reduce boiler-plate code (compare to the verbose example).</p>"},{"location":"examples/decorator/#simple-yaml-example","title":"Simple YAML Example","text":"<p>An example typer app: simple_app.py<pre><code>import typer\nfrom typer_config import use_yaml_config\n\napp = typer.Typer()\n\n\n@app.command()\n@use_yaml_config() # MUST BE AFTER @app.command() (1)\ndef main(\n    arg1: str,\n    opt1: str = typer.Option(...),\n    opt2: str = typer.Option(\"hello\"),\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>The <code>app.command()</code> decorator registers the function object in a lookup table, so we must transform our command before registration.</li> </ol> <p>This dynamically injects the <code>config</code> parameter into your command's signature such that <code>typer</code> is aware of it when parsing the command line. The <code>@use_*_config()</code> decorators take extra parameters, <code>param_name</code> and <code>param_help</code> to customize the appearance of the config parameter in the <code>typer</code> help menu. See the API reference for more details.</p> <p>And for the sake of completeness, it works the same as the other example:</p> <p>With a config file:</p> config.yml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre> <p>Note: this package also provides <code>use_json_config</code>, <code>use_toml_config</code>, and <code>use_dotenv_config</code> for those file formats.</p>"},{"location":"examples/decorator/#save-config-files","title":"Save Config Files","text":"<p>This example lets you save the parameters of the invoked command to a configuration file using the <code>@dump_config</code> decorator which operates on Typer commands (requested in issue #25).</p> <p>An example typer app: simple_app.py<pre><code>import typer\nfrom typer_config.decorators import dump_json_config, use_json_config\n\n\napp = typer.Typer()\n\n@app.command()\n@use_json_config() # before dump decorator (1)\n@dump_json_config(\"./dumped.json\") \ndef main(\n    arg1: str,\n    opt1: str = typer.Option(...),\n    opt2: str = typer.Option(\"hello\"),\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>If you put <code>@use_json_config</code> before <code>@dump_json_config</code>, you will not capture the <code>config</code> parameter in your config dump. You probably want this behavior to avoid cascading config files.</li> </ol> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --opt1 foo --opt2 bar baz\nfoo bar baz\n\n$ cat ./dumped.json\n{\"arg1\": \"baz\", \"opt1\": \"foo\", \"opt2\": \"bar\"}\n</code></pre> <p>Note: this package also provides <code>yaml_dumper</code> and <code>toml_dumper</code> for those file formats.</p>"},{"location":"examples/pydantic/","title":"Pydantic Validation Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file and uses pydantic to validate the file before continuing.</p> <p>An example typer app: simple_app.py<pre><code>from typing import Any, Dict\n\nfrom pydantic import BaseModel\nimport typer\nfrom typer_config import yaml_loader, conf_callback_factory\n\n\nclass AppConfig(BaseModel):\n    arg1: str\n    opt1: str\n    opt2: str\n\n\ndef validator_loader(param_value: str) -&gt; Dict[str, Any]:\n    conf = yaml_loader(param_value)\n    AppConfig.validate(conf)  # raises an exception if not valid\n    return conf\n\n\nvalidator_callback = conf_callback_factory(validator_loader)\n\napp = typer.Typer()\n\n\n@app.command()\ndef main(\n    arg1: str,\n    config: str = typer.Option(\n        \"\",\n        callback=validator_callback,\n        is_eager=True,  # THIS IS REALLY IMPORTANT (1)\n    ),\n    opt1: str = typer.Option(...),\n    opt2: str = typer.Option(\"hello\"),\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</li> </ol> <p>With a config file:</p> config.yml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> <pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre> <p>Note: this package also provides <code>json_conf_callback</code>, <code>toml_conf_callback</code>, and <code>dotenv_conf_callback</code> for those file formats.</p>"},{"location":"examples/pyproject/","title":"Pyproject TOML loader","text":"<p>If you use an unsupported file format or need to do extra processing of the file, you can make your own file loader and construct an appropriate callback.</p> <p>Suppose you want to specify parameters in a section of <code>pyproject.toml</code>:</p> pyproject.toml<pre><code>[tool.my_tool.parameters]\narg1 = \"stuff\"\nopt1 = \"things\"\nopt2 = \"nothing\"\n</code></pre> <p>Then, we can read the values in our typer CLI:</p> my_tool.py<pre><code>from typing import Any, Dict\n\nimport typer\nfrom typer_config import conf_callback_factory\nfrom typer_config.loaders import toml_loader\n\n\ndef pyproject_loader(param_value: str) -&gt; Dict[str, Any]:\n    if not param_value:  # set a default path to read from\n        param_value = \"pyproject.toml\"\n    pyproject = toml_loader(param_value)\n    conf = pyproject[\"tool\"][\"my_tool\"][\"parameters\"]\n    return conf\n\n\n### You can define the same loader using some provided combinators:\n#\n# from typer_config.loaders import default_value_loader, subpath_loader, toml_loader\n#\n# pyproject_loader = subpath_loader(\n#     default_value_loader(toml_loader, lambda: \"pyproject.toml\"),\n#     [\"tool\", \"my_tool\", \"parameters\"],\n# )\n\npyproject_callback = conf_callback_factory(pyproject_loader)\n\napp = typer.Typer()\n\n\n@app.command()\ndef main(\n    arg1: str,\n    config: str = typer.Option(\n        \"\",\n        callback=pyproject_callback,\n        is_eager=True,  # THIS IS REALLY IMPORTANT (1)\n    ),\n    opt1: str = typer.Option(...),\n    opt2: str = typer.Option(\"hello\"),\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <ol> <li>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</li> </ol> <p>And we get this behavior:</p> <pre><code>$ ls .\nmy_tool.py\nother.toml\npyproject.toml\n\n$ python my_tool.py\nthings nothing stuff\n\n$ python my_tool.py others\nthings nothing others\n\n$ python my_tool.py --config other.toml\nsomething else entirely\n</code></pre>"},{"location":"examples/schema/","title":"Schema Validation Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file and uses schema to validate the file before continuing.</p> <p>An example typer app: simple_app.py<pre><code>from typing import Any, Dict\n\nfrom schema import Schema\nimport typer\nfrom typer_config import yaml_loader, conf_callback_factory\n\n\nschema = Schema({\"arg1\": str, \"opt1\": str, \"opt2\": str})\n\n\ndef validator_loader(param_value: str) -&gt; Dict[str, Any]:\n    conf = yaml_loader(param_value)\n    conf = schema.validate(conf)  # raises an exception if not valid\n    return conf\n\n\nvalidator_callback = conf_callback_factory(validator_loader)\n\napp = typer.Typer()\n\n\n@app.command()\ndef main(\n    arg1: str,\n    config: str = typer.Option(\n        \"\",\n        callback=validator_callback,\n        is_eager=True,  # THIS IS REALLY IMPORTANT (1)\n    ),\n    opt1: str = typer.Option(...),\n    opt2: str = typer.Option(\"hello\"),\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</li> </ol> <p>With a config file:</p> config.yml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> <pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre> <p>Note: this package also provides <code>json_conf_callback</code>, <code>toml_conf_callback</code>, and <code>dotenv_conf_callback</code> for those file formats.</p>"},{"location":"examples/simple_yaml/","title":"Simple YAML Example","text":"<p>This simple example uses a <code>--config</code> option to load a configuration from a YAML file.</p> <p>An example typer app: simple_app.py<pre><code>import typer\nfrom typer_config import yaml_conf_callback\n\napp = typer.Typer()\n\n\n@app.command()\ndef main(\n    arg1: str,\n    config: str = typer.Option(\n        \"\",\n        callback=yaml_conf_callback,\n        is_eager=True,  # THIS IS REALLY IMPORTANT (1)\n    ),\n    opt1: str = typer.Option(...),\n    opt2: str = typer.Option(\"hello\"),\n):\n    typer.echo(f\"{opt1} {opt2} {arg1}\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre></p> <ol> <li>You must use <code>is_eager=True</code> in the parameter definition because that will cause it to be processed first.    If you don't use <code>is_eager</code>, then your parameter values will depend on the order in which they were processed (read: unpredictably).</li> </ol> <p>With a config file:</p> config.yml<pre><code>arg1: stuff\nopt1: things\nopt2: nothing\n</code></pre> <p>And invoked with python:</p> Terminal<pre><code>$ python simple_app.py --config config.yml\nthings nothing stuff\n\n$ python simple_app.py --config config.yml others\nthings nothing others\n\n$ python simple_app.py --config config.yml --opt1 people\npeople nothing stuff\n</code></pre> <p>Note: this package also provides <code>json_conf_callback</code>, <code>toml_conf_callback</code>, and <code>dotenv_conf_callback</code> for those file formats.</p>"}]}